{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KuboCD","text":""},{"location":"#why-kubocd","title":"Why KuboCD?","text":"<p>Most Kubernetes-ready applications provide a Helm chart. These charts are typically designed to be highly flexible and accommodate a wide range of use cases, which often makes their configuration complex.</p> <p>Moreover, deploying an application using a Helm chart requires a deep understanding of the Kubernetes ecosystem. Consequently, application deployment often falls to platform administrators or platform engineers.</p> <p>Even for experienced administrators, the verbosity of Helm configurations\u2014especially the repetition of variables\u2014can be tedious and error-prone. Industrializing these configurations is crucial for improving efficiency and reliability.</p> <p>KuboCD is a tool that empowers Platform Engineers to package applications in a way that simplifies deployment for other technical users (such as Developers and AppOps) by abstracting much of the underlying infrastructure and environment complexity.</p> <p>Beyond standard applications, KuboCD can provision core system components (e.g., ingress controllers, load balancers, Kubernetes operators), enabling the fully automated bootstrapping of a production-ready cluster from the ground up.</p>"},{"location":"#when-to-use-kubocd","title":"When to Use KuboCD","text":"<p>KuboCD is particularly useful when:</p> <ul> <li>You want to standardize application deployment workflows across teams and environments without requiring every user to master Helm or Kubernetes internals.</li> <li>You are already using GitOps tools like Flux or ArgoCD and need a structured way to package and manage applications as versioned, portable artifacts.</li> <li>You want to encapsulate application configuration and logic into reusable, declarative units (Packages) that are decoupled from cluster-specific deployment scripts.</li> <li>You need to simplify developer access to existing Helm charts while enforcing consistency and best practices through curated Releases.</li> <li>You want to bootstrap entire environments\u2014including base system components\u2014in a fully automated manner.</li> </ul>"},{"location":"#main-concepts","title":"Main Concepts","text":"<p>KuboCD introduces two core concepts that form the foundation of its deployment model:</p> <ul> <li> <p>Package:   A Package is an OCI-compliant container image that bundles an application descriptor along with one or more Helm charts. It serves as a standardized deployment unit, encapsulating everything needed to describe and install an application.</p> </li> <li> <p>Release:   A Release is a Kubernetes Custom Resource (CRD) that represents the deployment of a specific Package within a Kubernetes cluster. It defines how and where the application is deployed and manages its lifecycle.</p> </li> </ul>"},{"location":"#kubocd-flux-helm-and-gitops","title":"KuboCD, Flux, Helm, and GitOps","text":"<p>KuboCD is designed to integrate seamlessly with Flux, enabling a fully automated GitOps workflow. While Flux handles continuous delivery (synchronizing changes from Git to the cluster), KuboCD simplifies application packaging and deployment logic, making the overall delivery pipeline more modular, maintainable, and user-friendly.</p> <p>KuboCD is not a replacement for Helm. Quite the opposite: it builds upon Helm\u2019s proven capabilities and leverages the rich ecosystem of existing Helm charts.</p> <p>Most production-grade applications provide an official or community-maintained Helm chart. KuboCD makes these charts more accessible by abstracting the complexity of Helm-based deployments.</p> <p>By encapsulating Helm charts within standardized Packages and managing them via declarative Releases, KuboCD enables a broader audience\u2014including those with less Helm expertise\u2014to safely and efficiently deploy applications to Kubernetes.</p>"},{"location":"#feature-comparison-kubocd-vs-helm-vs-flux","title":"Feature Comparison: KuboCD vs. Helm vs. Flux","text":"Feature / Tool KuboCD Helm Flux Primary Role Application packaging &amp; deployment abstraction Templating and deploying Kubernetes manifests GitOps continuous delivery User Audience Platform Engineers, AppOps, Developers DevOps, Kubernetes Experts DevOps, SREs Ease of Use High (abstracts deployment logic) Medium (requires Helm knowledge) Medium (requires GitOps understanding) Supports GitOps \u2705 (via integration with Flux) \u26a0\ufe0f (manual integration needed) \u2705 (native GitOps controller) Uses Helm Charts \u2705 (packages &amp; manages them) \u2705 (core functionality) \u2705 (can deploy HelmReleases) Custom Resources Release, Context None (CLI and chart format) HelmRelease, Kustomization, etc. Deployment Abstraction \u2705 (encapsulates values, logic) \u274c (user-defined values needed at deploy) \u274c (relies on raw manifests or Helm) OCI Image Support \u2705 (Packages are OCI images) \u2705 (since Helm v3.8+) \u2705 (via Helm OCI support) Ideal Use Case Standardizing deployments across teams Managing complex app deployments manually Automating deployments from Git"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#documentation-structure","title":"Documentation Structure","text":"<p>The User Guide is structured as a step-by-step tutorial, designed to progressively introduce KuboCD features.</p> <p>The guide is complemented by a Reference section for detailed technical information.</p> <p>To get started, we recommend installing KuboCD using the method appropriate for your environment:</p> <ul> <li>Existing Cluster: Installing KuboCD on an Existing Cluster</li> <li>Local Workstation: Installing KuboCD on a Local Kind Cluster</li> </ul> <p>Once installed, proceed to A First Deployment.</p>"},{"location":"reference/500-package/","title":"The KuboCD Package Resource","text":"<p>A <code>Package</code> is an OCI-compliant container image that bundles an application descriptor and one or more Helm charts. As the standardized unit of deployment, it encapsulates everything needed to install and configure an application.</p> <p>See A first deployment for an introductory example.</p> <p>The OCI image is built from a YAML manifest described below.</p>"},{"location":"reference/500-package/#templating","title":"Templating","text":"<p>Some attributes support templating to render dynamic values. These are denoted as:</p> <ul> <li>Template(string): Renders a string.</li> <li>Template(bool): Renders a string convertible to a boolean (e.g., <code>true</code>, <code>false</code>, <code>1</code>, <code>0</code>, <code>t</code>, <code>f</code>).</li> <li>Template(list(string)): Renders a list of strings.</li> <li>Template(map): Renders a map/object.</li> <li>Template(duration): Renders a string convertible to a duration (e.g., <code>5m</code>, <code>1h</code>).</li> </ul>"},{"location":"reference/500-package/#package","title":"Package","text":"Field Type Required Description <code>apiVersion</code> String Yes The API version. Currently <code>v1alpha1</code>. <code>type</code> String No The resource type. Must be <code>Package</code> if specified. <code>name</code> String Yes The package name. Used in the OCI repository name. Must be a valid DNS Subdomain name. <code>tag</code> String Yes The specific tag for the OCI image. <code>description</code> Template(String) No A short description of the package. Default description for the <code>Release</code>. <code>usage</code> Template(String) No Usage information (e.g., access URLs) displayed after deployment. <code>protected</code> Bool No (Default: <code>false</code>) If <code>true</code>, prevents accidental deletion. Default for the <code>Release</code>. <code>schema.parameters</code> Map No Schema to validate <code>Release.parameters</code>. Supports standard JSON/OpenAPI or KuboCD simplified schema. <code>schema.context</code> Map No Schema to validate the injected <code>Context</code>. Supports standard JSON/OpenAPI or KuboCD simplified schema. <code>modules</code> List(Module) Yes The list of modules embedded in this package. <code>roles</code> Template(List(String)) No The roles this application fulfills. See Release Dependencies. <code>dependencies</code> Template(List(String)) No The roles this application depends on. See Release Dependencies."},{"location":"reference/500-package/#packagemodule","title":"Package.module","text":"<p>A <code>Module</code> defines a Helm Chart deployment.</p> Field Type Default Description <code>name</code> String - Required. Unique name for the module. Suffix for the generated <code>HelmRelease</code>. Use <code>noname</code> for no suffix. <code>source</code> Map - Required. Defines where to fetch the chart. Must contain exactly one of: helmRepository, git, oci, or local. <code>values</code> Template(Map) <code>null</code> Template for generating the Helm <code>values.yaml</code>. <code>enabled</code> Template(Bool) <code>true</code> Conditional deployment. If <code>false</code>, the module is skipped. <code>targetNamespace</code> Template(String) <code>{{ .Release.spec.targetNamespace }}</code> The namespace where the module is deployed. <code>onFailureStrategy</code> Template(String) <code>null</code> Strategy for failure handling. See Deployment Failure. <code>timeout</code> Template(Duration) <code>{config.defaultHelmTimeout}</code> Sets <code>spec.timeout</code> in the generated <code>HelmRelease</code>. <code>interval</code> Template(Duration) <code>{config.defaultHelmInterval}</code> Sets <code>spec.interval</code> in the generated <code>HelmRelease</code> (reconciliation frequency). <code>dependsOn</code> Template(List(String)) <code>null</code> List of other module names this module depends on. <code>specPatch</code> Template(Map) <code>null</code> Arbitrary patch applied to the <code>spec</code> of the generated Flux <code>HelmRelease</code>."},{"location":"reference/500-package/#packagemodulesourcehelmrepository","title":"Package.module.source.helmRepository","text":"<p>Fetches a Chart from an HTTP(S) Helm Repository.</p> Field Type Required Description <code>url</code> String Yes The repository URL. <code>chart</code> String Yes The chart name. <code>version</code> String Yes The chart version."},{"location":"reference/500-package/#packagemodulesourcegit","title":"Package.module.source.git","text":"<p>Fetches a Chart from a Git Repository.</p> Field Type Required Description <code>url</code> String Yes The repository URL. <code>branch</code> String Yes (if tag omitted) Git branch to fetch. <code>tag</code> String Yes (if branch omitted) Git tag to fetch. <code>path</code> String Yes Relative path to the chart directory (containing <code>Chart.yaml</code>). <code>extraFilePrefixes</code> List(String) No Include extra files/folders starting with these prefixes (relative to chart path)."},{"location":"reference/500-package/#packagemodulesourceoci","title":"Package.module.source.oci","text":"<p>Fetches a Chart stored as an OCI artifact.</p> Field Type Required Description <code>repository</code> String Yes The repository URL (without <code>oci://</code> prefix or tag). <code>tag</code> String Yes The image tag. <code>insecure</code> Bool No (Default: <code>false</code>) If <code>true</code>, allows unencrypted (HTTP) connections."},{"location":"reference/500-package/#packagemodulesourcelocal","title":"Package.module.source.local","text":"<p>Fetches a Chart from the local filesystem (relative to the Package manifest).</p> Field Type Required Description <code>path</code> String Yes Relative path to the chart directory."},{"location":"reference/510-release/","title":"The Release Kubernetes Resource","text":""},{"location":"reference/510-release/#release","title":"Release","text":"Field Type Required Description <code>apiVersion</code> String Yes Always <code>kubocd.kubotal.io/v1alpha1</code>. <code>kind</code> String Yes Always <code>Release</code>. <code>metadata</code> Map Yes Standard Kubernetes metadata (name, namespace, labels, etc.). <code>spec</code> Release.spec Yes The release specification."},{"location":"reference/510-release/#releasespec","title":"Release.spec","text":"Field Type Default Description <code>description</code> String <code>{Package.description}</code> A short description of the deployment. <code>package</code> Release.spec.package - Required. Defines the <code>Package</code> OCI image to deploy. <code>contexts</code> List(CrossNamespaceReference) <code>[]</code> Additional contexts to merge with the defaults. If <code>namespace</code> is omitted, <code>Release.metadata.namespace</code> is used. <code>protected</code> Bool <code>{Package.protected}</code> If <code>true</code>, prevents deletion of the Release (requires KuboCD webhook). <code>parameters</code> Template(Map) <code>null</code> Deployment parameters matching <code>Package.parameters.schema</code>. Note: Only the <code>.Context</code> root element is available for templating in this section. <code>targetNamespace</code> String <code>{Release.metadata.namespace}</code> The namespace where the application workload is deployed. <code>createNamespace</code> Bool <code>false</code> If <code>true</code>, creates <code>targetNamespace</code> if it does not exist. <code>roles</code> List(String) <code>[]</code> Appended to the <code>Package.roles</code> list. <code>dependencies</code> List(String) <code>[]</code> Appended to the <code>Package.dependencies</code> list. <code>skipDefaultContext</code> Bool <code>false</code> If <code>true</code>, ignores global and namespace-level default contexts. Only explicit contexts in <code>spec.contexts</code> are used. <code>modulesOverrides</code> List(Release.spec.moduleOverride) <code>[]</code> Overrides specific settings for individual modules. <code>debug</code> Release.spec.debug <code>false</code> Debugging options."},{"location":"reference/510-release/#releasespecmoduleoverride","title":"Release.spec.moduleOverride","text":"Field Type Default Description <code>module</code> String - Required. The name of the module to modify. <code>strategy</code> String <code>null</code> Overrides the failure handling strategy. See Deployment Failure. <code>timeout</code> Template(Duration) <code>null</code> Overrides the Helm deployment timeout. <code>interval</code> Template(Duration) <code>null</code> Overrides the Helm reconciliation interval. <code>specPatch</code> Map <code>null</code> A patch applied to the <code>spec</code> of the generated <code>HelmRelease</code> for this module."},{"location":"reference/510-release/#releasespecpackage","title":"Release.spec.package","text":"Field Type Default Description <code>repository</code> String - Required. OCI repository URL (without <code>oci://</code> or tag). <code>tag</code> String - Required. Image tag."},{"location":"reference/510-release/#forwarded-properties","title":"Forwarded Properties","text":"<p>The following Flux <code>OCIRepository</code> attributes can be overridden in this section and will be passed through to the generated resource:</p> <ul> <li><code>interval</code></li> <li><code>timeout</code></li> <li><code>secretRef</code></li> <li><code>certSecretRef</code></li> <li><code>proxySecretRef</code></li> <li><code>provider</code></li> <li><code>verify</code></li> <li><code>serviceAccountName</code></li> <li><code>insecure</code></li> <li><code>suspend</code></li> </ul> <p>See Flux OCIRepositorySpec for details.</p>"},{"location":"reference/510-release/#releasespecdebug","title":"Release.spec.debug","text":"Field Type Default Description <code>dumpContext</code> Bool <code>false</code> If <code>true</code>, saves the fully resolved context into the <code>status</code> field. Use sparingly as contexts can be large. (Prefer <code>kubocd render</code> for debugging). <code>dumpParameters</code> Bool <code>false</code> If <code>true</code>, saves resolved parameters into the <code>status</code> field."},{"location":"reference/510-release/#crossnamespacereference","title":"CrossNamespaceReference","text":"Field Type Required Description <code>name</code> String Yes Resource name. <code>namespace</code> String No Resource namespace. Defaults to local namespace if omitted."},{"location":"reference/520-context/","title":"The Context Kubernetes Resource","text":"<p>See The Context Resource for usage examples.</p>"},{"location":"reference/520-context/#context","title":"Context","text":"Field Type Required Description <code>apiVersion</code> String Yes Always <code>kubocd.kubotal.io/v1alpha1</code>. <code>kind</code> String Yes Always <code>Context</code>. <code>metadata</code> Map Yes Standard Kubernetes metadata. <code>spec</code> Context.spec Yes The context specification."},{"location":"reference/520-context/#contextspec","title":"Context.spec","text":"Field Type Default Description <code>description</code> String <code>null</code> A short description. <code>protected</code> Bool <code>false</code> If <code>true</code>, prevents deletion (requires KuboCD webhook). <code>context</code> Map - Required. The free-form context data structure."},{"location":"reference/530-config/","title":"The Config Kubernetes Resource","text":""},{"location":"reference/530-config/#config","title":"Config","text":"Field Type Required Description <code>apiVersion</code> String Yes Always <code>kubocd.kubotal.io/v1alpha1</code>. <code>kind</code> String Yes Always <code>Config</code>. <code>metadata</code> Map Yes Standard Kubernetes metadata. <code>spec</code> Config.spec Yes The configuration specification."},{"location":"reference/530-config/#configspec","title":"Config.spec","text":"Field Type Default Description <code>clusterRoles</code> List(String) <code>[]</code> List of roles fulfilled by external (non-KuboCD) applications. See Cluster Roles. <code>defaultContexts</code> List(CrossNamespaceReference) <code>[]</code> Global default contexts applied to all <code>Releases</code>. See The Context Resource. <code>defaultNamespaceContexts</code> List(String) <code>[]</code> Context names to automatically look up in the Release's namespace. <code>onFailureStrategies</code> List(onFailureStrategy) <code>[]</code> Definitions of deployment failure strategies. See Deployment Failure. <code>defaultOnFailureStrategy</code> String <code>null</code> The name of the strategy to use by default. <code>defaultHelmTimeout</code> Duration <code>3m</code> Default timeout for Helm deployments (<code>HelmRelease.spec.timeout</code>). <code>defaultHelmInterval</code> Duration <code>30m</code> Default reconciliation interval for Helm releases (<code>HelmRelease.spec.interval</code>). <code>defaultPackageInterval</code> Duration <code>30m</code> Default interval for checking OCI package updates (<code>OCIRepository.spec.interval</code>). <code>specPatch</code> Template(Map) <code>null</code> Global patch applied to the <code>spec</code> section of all generated Flux <code>HelmRelease</code> resources. <code>packageRedirects</code> - - Reserved for future extensions. <code>imageRedirects</code> - - Reserved for future extensions."},{"location":"reference/530-config/#onfailurestrategy","title":"onFailureStrategy","text":"Field Type Required Description <code>name</code> String Yes Unique strategy name. <code>strategy</code> Map Yes Flux-compatible configuration for <code>install</code> and <code>upgrade</code> strategies."},{"location":"reference/530-config/#crossnamespacereference","title":"CrossNamespaceReference","text":"Field Type Required Description <code>name</code> String Yes Resource name. <code>namespace</code> String No Resource namespace. Defaults to local namespace if omitted."},{"location":"user-guide/110-kind/","title":"Installing KuboCD on a Local Kind Cluster","text":"<p>This guide details the process of setting up a local Kubernetes cluster using Kind (Kubernetes in Docker), followed by the installation of FluxCD and KuboCD.</p> <p>Tip</p> <p>Existing Cluster? If you already have a Kubernetes cluster, you can skip the cluster creation steps and proceed directly to Installation on an Existing Cluster.</p>"},{"location":"user-guide/110-kind/#prerequisites","title":"Prerequisites","text":"<p>Ensure the following tools are installed on your workstation:</p> <ul> <li>Docker</li> <li>kubectl</li> <li>Helm</li> <li>Kind</li> <li>Flux CLI</li> </ul> <p>Please ensure that:</p> <ul> <li>Docker is running.</li> <li>You have an active internet connection.</li> <li>Ports 80 and 443 are available on your local machine.</li> </ul> <p>You will also need access to an OCI-compatible container registry with push permissions. This is required for storing KuboCD Packages as OCI artifacts.</p>"},{"location":"user-guide/110-kind/#create-a-kind-cluster","title":"Create a Kind Cluster","text":"<p>First, create a configuration file that defines the necessary port mappings for the ingress controller:</p> <pre><code>cat &gt;/tmp/kubodoc-config.yaml &lt;&lt;EOF\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nname: kubodoc\nnodes:\n- role: control-plane\n  extraPortMappings:\n  - containerPort: 30080\n    hostPort: 80\n    protocol: TCP\n  - containerPort: 30443\n    hostPort: 443\n    protocol: TCP\nEOF\n</code></pre> <p>Note</p> <p>The <code>extraPortMappings</code> configuration exposes services, such as the ingress controller, directly to your local machine.</p> <p>Next, create the cluster using the configuration file:</p> <pre><code>kind create cluster --config /tmp/kubodoc-config.yaml\n</code></pre> <p>This command provisions a single-node cluster that functions as both the control plane and a worker node.</p> <p>Example Output:</p> <pre><code>Creating cluster \"kubodoc\" ...\n \u2713 Ensuring node image (kindest/node:v1.32.2)\n \u2713 Preparing nodes\n \u2713 Writing configuration\n \u2713 Starting control-plane\n \u2713 Installing CNI\n \u2713 Installing StorageClass\nSet kubectl context to \"kind-kubodoc\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-kubodoc\n</code></pre> <p>Verify that the cluster is operational:</p> <pre><code>kubectl get pods -A\n</code></pre> <pre><code>NAMESPACE            NAME                                            READY   STATUS    RESTARTS   AGE\nkube-system          coredns-668d6bf9bc-nwzqj                        1/1     Running   0          52s\nkube-system          coredns-668d6bf9bc-xgv9f                        1/1     Running   0          52s\nkube-system          etcd-kubodoc-control-plane                      1/1     Running   0          59s\nkube-system          kindnet-xwfp8                                   1/1     Running   0          52s\nkube-system          kube-apiserver-kubodoc-control-plane            1/1     Running   0          59s\nkube-system          kube-controller-manager-kubodoc-control-plane   1/1     Running   0          58s\nkube-system          kube-proxy-6hv6w                                1/1     Running   0          52s\nkube-system          kube-scheduler-kubodoc-control-plane            1/1     Running   0          59s\nlocal-path-storage   local-path-provisioner-7dc846544d-k8bhb         1/1     Running   0          52s\n</code></pre>"},{"location":"user-guide/110-kind/#install-flux","title":"Install Flux","text":""},{"location":"user-guide/110-kind/#install-the-flux-cli","title":"Install the Flux CLI","text":"<p>If not already installed, please refer to the Flux CLI installation guide.</p>"},{"location":"user-guide/110-kind/#deploy-flux-standalone-mode","title":"Deploy Flux (Standalone Mode)","text":"<p>Perform a standalone installation of Flux (without linking a Git repository initially):</p> <pre><code>flux install\n</code></pre> <pre><code>\u271a generating manifests\n\u2714 manifests build completed\n\u25ba installing components in flux-system namespace\n...\n\u2714 notification-controller: deployment ready\n\u2714 source-controller: deployment ready\n\u2714 install finished\n</code></pre> <p>Verify the deployment:</p> <pre><code>kubectl -n flux-system get pods\n</code></pre> <pre><code>NAME                                       READY   STATUS    RESTARTS   AGE\nhelm-controller-b6767d66-q27gd             1/1     Running   0          14m\nkustomize-controller-5b56686fbc-hpkhl      1/1     Running   0          14m\nnotification-controller-58ffd586f7-bbvwv   1/1     Running   0          14m\nsource-controller-6ff87cb475-hnmxv         1/1     Running   0          14m\n</code></pre> <p>Tip</p> <p>Minimal Installation For a lighter setup, you can install only the components required by KuboCD: <code>flux install --components source-controller,helm-controller</code></p>"},{"location":"user-guide/110-kind/#install-kubocd","title":"Install KuboCD","text":"<p>Deploy KuboCD using Helm:</p> <pre><code>helm -n kubocd install kubocd-ctrl --create-namespace oci://quay.io/kubocd/charts/kubocd-ctrl --version v0.3.0\n</code></pre>"},{"location":"user-guide/110-kind/#webhook-based-features","title":"Webhook-Based Features","text":"<p>Certain advanced KuboCD features, such as Release protection, depend on a Kubernetes validating webhook.</p> <p>Enabling this webhook requires cert-manager for TLS certificate management. We will cover how to package and install cert-manager using KuboCD in a later section. Once cert-manager is available, you can proceed to deploy the KuboCD webhook.</p>"},{"location":"user-guide/110-kind/#install-the-kubocd-cli","title":"Install the KuboCD CLI","text":"<p>Download the KuboCD CLI from the GitHub releases page.</p> <p>Rename the binary to <code>kubocd</code>, make it executable, and move it to a directory in your system <code>$PATH</code>:</p> <pre><code># Replace &lt;binary-name&gt; with the actual downloaded filename\nmv &lt;binary-name&gt; kubocd\nchmod +x kubocd\nsudo mv kubocd /usr/local/bin/\n</code></pre> <p>Verify the installation:</p> <pre><code>kubocd version\n</code></pre> <p>You are now ready for your first deployment with KuboCD.</p>"},{"location":"user-guide/120-existing-cluster/","title":"Installing KuboCD on an Existing Cluster","text":"<p>If you already manage a Kubernetes cluster, you can use it to test KuboCD.</p> <p>Tip</p> <p>No cluster? If you do not have a cluster available, you can install a Kind cluster on your local workstation.</p>"},{"location":"user-guide/120-existing-cluster/#prerequisites","title":"Prerequisites","text":"<p>Ensure the following tools are installed on your workstation:</p> <ul> <li>Docker</li> <li>kubectl</li> <li>Helm</li> <li>Flux CLI</li> </ul> <p>Please ensure that:</p> <ul> <li>Docker is running.</li> <li>You have an active internet connection.</li> <li>You have full administrative privileges on the target cluster.</li> </ul> <p>You will also need access to an OCI-compatible container registry with push permissions. This is required for storing KuboCD Packages as OCI artifacts.</p>"},{"location":"user-guide/120-existing-cluster/#install-flux","title":"Install Flux","text":""},{"location":"user-guide/120-existing-cluster/#install-the-flux-cli","title":"Install the Flux CLI","text":"<p>If not already installed, please refer to the Flux CLI installation guide.</p>"},{"location":"user-guide/120-existing-cluster/#deploy-flux-standalone-mode","title":"Deploy Flux (Standalone Mode)","text":"<p>If Flux is not installed on your cluster, perform a standalone installation (without linking a Git repository initially):</p> <pre><code>flux install\n</code></pre> <pre><code>\u271a generating manifests\n\u2714 manifests build completed\n\u25ba installing components in flux-system namespace\n...\n\u2714 notification-controller: deployment ready\n\u2714 source-controller: deployment ready\n\u2714 install finished\n</code></pre> <p>Verify the deployment:</p> <pre><code>kubectl -n flux-system get pods\n</code></pre> <pre><code>NAME                                       READY   STATUS    RESTARTS   AGE\nhelm-controller-b6767d66-q27gd             1/1     Running   0          14m\nkustomize-controller-5b56686fbc-hpkhl      1/1     Running   0          14m\nnotification-controller-58ffd586f7-bbvwv   1/1     Running   0          14m\nsource-controller-6ff87cb475-hnmxv         1/1     Running   0          14m\n</code></pre> <p>Tip</p> <p>Minimal Installation For a lighter setup, you can install only the components required by KuboCD: <code>flux install --components source-controller,helm-controller</code></p>"},{"location":"user-guide/120-existing-cluster/#install-kubocd","title":"Install KuboCD","text":"<p>Deploy the KuboCD controller using Helm:</p> <pre><code>helm -n kubocd install kubocd-ctrl --create-namespace oci://quay.io/kubocd/charts/kubocd-ctrl --version v0.3.0\n</code></pre>"},{"location":"user-guide/120-existing-cluster/#enable-webhook-based-features","title":"Enable Webhook-Based Features","text":"<p>Certain advanced KuboCD features, such as Release protection, depend on a Kubernetes validating webhook.</p> <p>To enable these features, you must deploy the webhook component alongside the controller. This webhook requires cert-manager to handle TLS certificate provisioning.</p> <p>If <code>cert-manager</code> is already installed on your cluster, you can deploy the webhook using:</p> <pre><code>helm -n kubocd install kubocd-wh oci://quay.io/kubocd/charts/kubocd-wh --version v0.3.0\n</code></pre> <p>Note</p> <p>No cert-manager? If you don't have <code>cert-manager</code> installed, don't worry. We will cover how to package and install it using KuboCD in a later section.</p>"},{"location":"user-guide/120-existing-cluster/#install-the-kubocd-cli","title":"Install the KuboCD CLI","text":"<p>Download the KuboCD CLI from the GitHub releases page.</p> <p>Rename the binary to <code>kubocd</code>, make it executable, and move it to a directory in your system <code>$PATH</code>:</p> <pre><code># Replace &lt;binary-name&gt; with the downloaded filename\nmv &lt;binary-name&gt; kubocd\nchmod +x kubocd\nsudo mv kubocd /usr/local/bin/\n</code></pre> <p>Verify the installation:</p> <pre><code>kubocd version\n</code></pre> <p>You are now ready for your first deployment with KuboCD.</p>"},{"location":"user-guide/130-a-first-deployment/","title":"A First Deployment with KuboCD","text":""},{"location":"user-guide/130-a-first-deployment/#package-definition","title":"Package Definition","text":"<p>For this initial deployment, we will use a simple example: a lightweight web application called podinfo.</p> <p>A Package in KuboCD is defined using a YAML manifest. Below is an example that wraps the <code>podinfo</code> application:</p> podinfo-p01.yaml <pre><code>apiVersion: v1alpha1\ntype: Package\nname: podinfo\ntag: 6.7.1-p01\nschema:\n  parameters:\n    $schema: http://json-schema.org/schema#\n    additionalProperties: false\n    properties:\n      fqdn:\n        type: string\n      ingressClassName:\n        default: nginx\n        type: string\n    required:\n      - fqdn\n    type: object\nmodules:\n  - name: main\n    source:\n      helmRepository:\n        url: https://stefanprodan.github.io/podinfo\n        chart: podinfo\n        version: 6.7.1\n    values: |\n      ingress:\n        enabled: true\n        className: {{ .Parameters.ingressClassName }}\n        hosts:\n          - host: {{ .Parameters.fqdn }}\n            paths:\n              - path: /\n                pathType: ImplementationSpecific\n</code></pre> <p>A KuboCD Package is NOT a native Kubernetes resource.</p> <p>Tip</p> <p>You can find most samples used in this documentation in the samples directory.</p>"},{"location":"user-guide/130-a-first-deployment/#attribute-description","title":"Attribute Description","text":"<ul> <li><code>apiVersion</code> (Required): Defines the version of the KuboCD Package format. Currently, the only supported value is <code>v1alpha1</code>.</li> <li><code>type</code>: Specifies the resource type. Must be <code>Package</code> (default).</li> <li><code>name</code>: The package name. This is used as the OCI image name.</li> <li><code>tag</code> (Required): The version tag of the OCI image. We recommend the following convention:<ul> <li>Use the Helm chart version of the main module as a base.</li> <li>Append <code>-pXX</code>, where <code>XX</code> denotes the packaging revision (e.g., configuration changes for the same chart version).</li> </ul> </li> <li><code>schema.parameters</code>: Defines input parameters for the package using standard OpenAPI/JSON Schema. This enables validation and documentation at deployment time.<ul> <li>If omitted, the release will not accept parameters.</li> </ul> </li> <li><code>modules</code> (Required): A package contains one or more Helm charts, each defined as a module.<ul> <li><code>modules[X].name</code> (Required): A unique name for the module. Here, we use <code>main</code>.</li> <li><code>modules[X].source</code> (Required): The source of the Helm chart. This example uses a Helm repository, but OCI registries, Git repositories, or local charts are also supported.</li> <li><code>values</code>: A template rendered into <code>values.yaml</code> for Helm.<ul> <li>Uses the same templating engine as Helm.</li> <li>The data model includes a <code>.Parameters</code> object containing values provided during deployment (via the <code>Release</code> object).</li> <li>Although strictly a string, it is written as YAML block to allow full templating flexibility.</li> </ul> </li> </ul> </li> </ul> <p>Required Fields</p> <p>Attributes marked (Required) are mandatory.</p> <p>Tip</p> <p>More attributes and advanced features will be introduced later in the documentation.</p>"},{"location":"user-guide/130-a-first-deployment/#package-build","title":"Package Build","text":"<p>Once the package definition is complete, the next step is to generate the OCI image.</p> <p>KuboCD uses an OCI-compatible container registry to store and distribute packages. You must have push access to a registry.</p> <p>Tested registries:</p> <ul> <li><code>quay.io</code> (Red Hat)</li> <li><code>ghcr.io</code> (GitHub)</li> <li>distribution registry</li> </ul> <p>Other OCI-compliant registries should also work. </p> <p>Docker Hub is currently not supported.</p> <p>Ensure you are authenticated with your registry:</p> <pre><code>docker login quay.io\n</code></pre> <p>or</p> <pre><code>docker login ghcr.io\n</code></pre> <p>Authentication</p> <p>If interactive authentication is not possible (e.g., in CI/CD pipelines), KuboCD allows providing credentials via environment variables: <code>KCD_OCI_{REGISTRY}_USER</code> and <code>KCD_OCI_{REGISTRY}_SECRET</code>.</p> <p>Replace <code>{REGISTRY}</code> with an identifier for the target registry, constructed as follows: - Replace characters <code>.</code>, <code>:</code>, <code>/</code>, and <code>-</code> with <code>_</code> - Convert to uppercase</p> <p>For example, for <code>quay.io</code>, use <code>KCD_OCI_QUAY_IO_USER</code> and <code>KCD_OCI_QUAY_IO_SECRET</code>.</p> <p>Note: The older <code>KCD_OCI_USER</code> and <code>KCD_OCI_SECRET</code> variables are deprecated.</p> <p>Tip: Run the <code>package</code> command with <code>--logLevel debug</code> to see the expected environment variable names.</p> <p>Depending on the registry, the image may be pushed under an organization or namespace. Here, we use <code>quay.io/kubodoc</code>.</p> <p>To build and push the package image:</p> <pre><code>kubocd package packages/podinfo-p01.yaml --ociRepoPrefix quay.io/kubodoc/packages\n</code></pre> <p>Note</p> <p>Adjust <code>--ociRepoPrefix</code> to match your registry setup.The <code>packages</code> suffix is optional.</p> <p>The resulting repository and tag are derived from the package manifest:</p> <ul> <li>Repository = <code>--ociRepoPrefix</code> + package <code>name</code></li> <li>Tag = package <code>tag</code></li> </ul> <p>Expected Output:</p> <pre><code>====================================== Packaging package 'podinfo-p01.yaml'\n--- Handling module 'main':\nFetching chart podinfo:6.7.1...\nChart: podinfo:6.7.1\n--- Packaging\nGenerating index file\nWrap all in assembly.tgz\n--- push OCI image: quay.io/kubodoc/packages/podinfo:6.7.1-p01\nSuccessfully pushed\n</code></pre> <p>You can set the repository prefix globally via an environment variable to avoid repeating the flag:</p> <pre><code>export OCI_REPO_PREFIX=quay.io/kubodoc/packages\n</code></pre> <p>Then simply run:</p> <pre><code>kubocd package packages/podinfo-p01.yaml\n</code></pre> <p>Image Visibility</p> <p>By default, pushed images may be private. To allow deployment without extra configuration, ensure the image is public.  If you keep the image private, you must provide authentication credentials in the <code>Release</code> configuration (explained later).</p>"},{"location":"user-guide/130-a-first-deployment/#releasing-the-application","title":"Releasing the Application","text":"<p>To deploy the application, define a KuboCD <code>Release</code> custom resource:</p> podinfo1-basic.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo1\n  namespace: default\nspec:\n  description: A first sample release of podinfo\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p01\n    interval: 30m\n  parameters:\n    fqdn: podinfo1.ingress.kubodoc.local\n</code></pre>"},{"location":"user-guide/130-a-first-deployment/#attribute-description_1","title":"Attribute Description","text":"<ul> <li><code>spec.description</code>: (Optional) A short description.</li> <li><code>spec.package.repository</code>: The OCI image repository containing the package.</li> <li><code>spec.package.tag</code>: The image tag, matching the package manifest.</li> <li><code>spec.package.interval</code>: (Optional) How frequently KuboCD checks for updates (e.g., <code>30m</code>).</li> <li><code>spec.parameters</code>: The values required by the package schema. Here, only <code>fqdn</code> is needed.</li> </ul>"},{"location":"user-guide/130-a-first-deployment/#deploy","title":"deploy","text":"<ol> <li>Adjust the repository and parameters manifest if needed.</li> <li>Apply the Release:</li> </ol> <pre><code>kubectl apply -f releases/podinfo1-basic.yaml\n</code></pre> <p>Monitor the status:</p> <pre><code>kubectl get releases\n</code></pre> <pre><code>NAME       REPOSITORY                         TAG         CONTEXTS   STATUS   READY   WAIT   PRT   AGE     DESCRIPTION\npodinfo1   quay.io/kubodoc/packages/podinfo   6.7.1-p01              READY    1/1            -     6m40s   A first sample release of podinfo\n</code></pre> <p>Verify the pod is running:</p> <pre><code>kubectl get pods\n</code></pre> <pre><code>NAME                             READY   STATUS    RESTARTS   AGE\npodinfo1-main-779b6b9fd4-zbgbx   1/1     Running   0          8h\n</code></pre>"},{"location":"user-guide/130-a-first-deployment/#preflight-check","title":"Preflight Check","text":"<p>Before deploying, it is good practice to test the <code>Release</code> using the <code>render</code> CLI command:</p> <pre><code>kubocd render releases/podinfo1-basic.yaml\n</code></pre> <p>See the KuboCD CLI section for details.</p>"},{"location":"user-guide/140-under-the-hood/","title":"Under the Hood (KuboCD Components)","text":"<p>Behind the scenes, KuboCD creates several Flux resources to manage deployments. You can inspect these resources to debug issues or understand the internal workings.</p> <p>Check the events for the <code>Release</code> created earlier:</p> <pre><code>kubectl describe release podinfo1\n</code></pre> <p>Events are generated for each Flux resource created:</p> <pre><code>......\nEvents:\n  Type    Reason                 Age   From     Message\n  ----    ------                 ----  ----     -------\n  Normal  OCIRepositoryCreated   49s   release  Created OCIRepository \"kcd-podinfo1\"\n  Normal  HelmRepositoryCreated  45s   release  Created HelmRepository \"kcd-podinfo1\"\n  Normal  HelmReleaseCreated     44s   release  Created HelmRelease \"podinfo1-main\"\n</code></pre> <p>All resources are created in the same namespace as the <code>Release</code> object (in this case, <code>default</code>).</p>"},{"location":"user-guide/140-under-the-hood/#the-ocirepository","title":"The OCIRepository","text":"<p>This Flux resource is responsible for pulling the KuboCD package image:</p> <pre><code>kubectl get OCIRepository\n</code></pre> <pre><code>NAME           URL                                      READY   STATUS                                                                                                           AGE\nkcd-podinfo1   oci://quay.io/kubodoc/packages/podinfo   True    stored artifact for digest '6.7.1-p01@sha256:985e4e2f89a4b17bd5cc2936a0b305df914ae479e0b8c96e61cb22725b61cd24'   9m1s\n</code></pre> <p>Tip</p> <p>If the release is stuck in the <code>WAIT_OCI</code> state, check this resource and its events. Common issues include:</p> <ul> <li>Incorrect URL</li> <li>Image is private (needs to be public or have authentication configured)</li> </ul> <p>To force a refresh (e.g., to load a modified OCI image before the sync period expires), you can manually delete this resource:</p> <pre><code>kubectl delete ocirepository kcd-podinfo1\n</code></pre> <p>KuboCD will automatically recreate it.</p>"},{"location":"user-guide/140-under-the-hood/#naming","title":"Naming","text":"<p>The <code>OCIRepository</code> is a namespaced resource located in the same namespace as the <code>Release</code>. Its name is derived from the <code>Release</code> name, prefixed with <code>kcd-</code>.</p>"},{"location":"user-guide/140-under-the-hood/#the-helmrepository","title":"The HelmRepository","text":"<p>Since the <code>podinfo</code> Helm chart is embedded in the package, it must be exposed to Flux via an internal Helm repository. KuboCD creates a <code>HelmRepository</code> resource pointing to its internal server:</p> <pre><code>kubectl get HelmRepository\n</code></pre> <pre><code>NAME           URL                                                                            AGE    READY   STATUS\nkcd-podinfo1   http://kubocd-ctrl-controller-helm-repository.kubocd.svc/hr/default/podinfo1   105m   True    stored artifact: revision 'sha256:d8db03cf45ecd75064c2a2582812dc4df5cd624d0e295b24ff79569bf46a070b'\n</code></pre> <p>This step rarely causes errors unless the internal controller is unreachable.</p>"},{"location":"user-guide/140-under-the-hood/#naming_1","title":"Naming","text":"<p>The <code>HelmRepository</code> is located in the same namespace as the <code>Release</code>. Its name matches the <code>Release</code> name, prefixed with <code>kcd-</code>.</p>"},{"location":"user-guide/140-under-the-hood/#the-helmrelease","title":"The HelmRelease","text":"<p>This Flux resource manages the actual Helm chart deployment.</p> <pre><code>kubectl get HelmRelease\n</code></pre> <pre><code>NAME                AGE     READY   STATUS\npodinfo1-main   7m29s   True    Helm install succeeded for release default/kcd-podinfo1-main.v1 with chart podinfo@6.7.1\n</code></pre> <p>Note</p> <p>One <code>HelmRelease</code> is created per module in the package.</p> <p>If the release is stuck in <code>WAIT_HREL</code>, inspect this resource:</p> <pre><code>kubectl describe helmrelease podinfo1-main\n</code></pre> <pre><code>.....\nEvents:\n  Type    Reason            Age    From             Message\n  ----    ------            ----   ----             -------\n  Normal  HelmChartCreated  4m38s  helm-controller  Created HelmChart/default/default-podinfo1-main with SourceRef 'HelmRepository/default/kcd-podinfo1'\n  Normal  InstallSucceeded  4m37s  helm-controller  Helm install succeeded for release default/podinfo1-main.v1 with chart podinfo@6.7.1\n</code></pre> <p>A key troubleshooting step is to verify the generated <code>values</code> passed to the Helm chart:</p> <p>Note</p> <p>This requires the yq tool.</p> <pre><code>kubectl get HelmRelease podinfo1-main -o yaml | yq '.spec.values'\n</code></pre> <pre><code>ingress:\n  className: nginx\n  enabled: true\n  hosts:\n    - host: podinfo1.ingress.kubodoc.local\n      paths:\n        - path: /\n          pathType: ImplementationSpecific\n</code></pre> <p>Note</p> <p>If a deployment fails, you may need to wait for the Helm timeout (default: 3 minutes) to see the failure reason. This timeout can be configured in the <code>Package</code> or the <code>Release</code>.</p> <p>Tip</p> <p>You can also check the generated <code>values</code> using the CLI:</p> <pre><code>kubocd render releases/podinfo1-basic.yaml\n</code></pre> <p>See the KuboCD CLI section for details.</p>"},{"location":"user-guide/140-under-the-hood/#naming_2","title":"Naming","text":"<p>The <code>HelmRelease</code> resides in the same namespace as the <code>Release</code>.</p> <p>Its name usually follows the pattern: <code>&lt;Release name&gt;-&lt;ModuleName&gt;</code>.</p> <p>The corresponding Helm deployment (stored as a Kubernetes Secret) also follows this naming convention:</p> <pre><code>kubectl get secrets\nNAME                                  TYPE                 DATA   AGE\nsh.helm.release.v1.podinfo1-main.v1   helm.sh/release.v1   1      66m\n</code></pre> <p>Since many Helm charts use the release name as a base for resource naming, this can lead to redundant suffixes (e.g., <code>podinfo1-main-...</code>).</p> <p>Example pod name: <pre><code>NAME                             READY   STATUS    RESTARTS   AGE\npodinfo1-main-779b6b9fd4-zbgbx   1/1     Running   0          8h\n</code></pre></p> <p>To avoid this, KuboCD supports a special module name: <code>noname</code>. When a module is named <code>noname</code>, the corresponding <code>HelmRelease</code> (and derived resources) uses only the <code>Release</code> name.</p> <p>Note: Since module names must be unique, a package can contain only one <code>noname</code> module.</p> <p>The next chapter demonstrates this feature.</p>"},{"location":"user-guide/150-ingress-controller/","title":"Setting Up the Ingress Controller","text":"<p>Warning</p> <p>Existing Clusters: If you are using an existing cluster, an ingress controller is likely already installed. Do not install another one. However, we recommend reading this section as it introduces several new features.</p> <p>If you are following the local <code>kind</code> cluster guide, you must install an ingress controller to support the <code>Ingress</code> resources.</p> <p>Check the current <code>Ingress</code> object created by the <code>podinfo</code> deployment:</p> <pre><code>kubectl get ingresses\n</code></pre> <pre><code>NAME            CLASS   HOSTS                            ADDRESS   PORTS   AGE\npodinfo1-main   nginx   podinfo1.ingress.kubodoc.local             80      6m33s\n</code></pre> <p>The ingress is currently inactive because no controller is running.</p>"},{"location":"user-guide/150-ingress-controller/#build-the-ingress-nginx-package","title":"Build the Ingress-Nginx Package","text":"<p>Below is a sample package definition for the <code>ingress-nginx</code> controller.</p> <p>Warning</p> <p>This configuration is specific to our local Kind cluster setup, leveraging <code>portMapping</code> and <code>NodePorts</code>.</p> ingress-nginx-p01.yaml <pre><code>apiVersion: v1alpha1\nname: ingress-nginx\ntag: 4.12.1-p01\nprotected: true\nmodules:\n  - name: noname\n    timeout: 4m\n    source:\n      helmRepository:\n        url: https://kubernetes.github.io/ingress-nginx\n        chart: ingress-nginx\n        version: 4.12.1\n    values:\n      controller:\n        extraArgs:\n          enable-ssl-passthrough: true\n        service:\n          type: NodePort\n          nodePorts:\n            http: \"30080\"\n            https: \"30443\"\nroles:\n  - ingress\n</code></pre> <p>Key Differences from the <code>podinfo</code> Package:</p> <ul> <li><code>protected: true</code>: Prevents accidental deletion of the release. (Requires the KuboCD webhook to be enforced).</li> <li><code>modules[0].name</code>: The value <code>noname</code> prevents appending the module name to the Helm release and derived objects.</li> <li><code>modules[0].timeout: 4m</code>: Overrides the default timeout (<code>3m</code>) to accommodate the Helm chart deployment time.</li> <li><code>modules[0].values</code>: Pure YAML is used here instead of a templated string since no dynamic parameters are needed.</li> <li><code>roles</code>: Assigns the package to the <code>ingress</code> role. This is used for dependency management (discussed later).</li> </ul> <p>Build the package:</p> <pre><code>kubocd pack packages/ingress-nginx-p01.yaml\n</code></pre> <pre><code>====================================== Packaging package 'ingress-nginx.yaml'\n--- Handling module 'noname':\nFetching chart ingress-nginx:4.12.1...\nChart: ingress-nginx:4.12.1\n--- Packaging\nGenerating index file\nWrap all in assembly.tgz\n--- push OCI image: quay.io/kubodoc/packages/ingress-nginx:4.12.1-p01\nSuccessfully pushed\n</code></pre>"},{"location":"user-guide/150-ingress-controller/#deploy-the-package","title":"Deploy the Package","text":"<p>Define the <code>Release</code> resource:</p> ingress-nginx.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: ingress-nginx\n  namespace: kubocd\nspec:\n  description: The Ingress controller\n  protected: false\n  package:\n    repository: quay.io/kubodoc/packages/ingress-nginx\n    tag: 4.12.1-p01\n  targetNamespace: ingress-nginx\n  createNamespace: true\n</code></pre> <p>Key Features:</p> <ul> <li><code>metadata.namespace: kubocd</code>: Deployed in a restricted system namespace.</li> <li><code>spec.protected: false</code>: Demonstrates overriding the package-level <code>protected</code> flag at the release level.</li> <li><code>spec.targetNamespace: ingress-nginx</code>: Installs the controller in its own dedicated namespace.</li> <li><code>spec.createNamespace: true</code>: Automatically creates the target namespace if missing.</li> <li><code>spec.package.interval</code>: Defaults to <code>30m</code>.</li> </ul> <p>Apply the release:</p> <pre><code>kubectl apply -f releases/ingress-nginx.yaml\n</code></pre> <p>Check the status:</p> <pre><code>kubectl -n kubocd get release\n</code></pre> <pre><code>NAME            REPOSITORY                               TAG          CONTEXTS   STATUS   READY   WAIT   PRT   AGE   DESCRIPTION\ningress-nginx   quay.io/kubodoc/packages/ingress-nginx   4.12.1-p01              READY    1/1            -     86s   The Ingress controller\n</code></pre> <p>Verify the pod:</p> <pre><code>kubectl -n ingress-nginx get pods\n</code></pre> <pre><code>NAME                                        READY   STATUS    RESTARTS   AGE\ningress-nginx-controller-658fbb96d5-hctqp   1/1     Running   0          4m12s\n</code></pre> <p>Note: If the pod name still includes <code>noname</code> (e.g., <code>ingress-nginx-noname-controller-...</code>), you may be using a KuboCD version older than <code>v0.2.3</code>.</p>"},{"location":"user-guide/150-ingress-controller/#configure-dns","title":"Configure DNS","text":"<p>To access <code>podinfo</code>, you need a DNS entry matching the <code>fqdn</code> parameter.</p> <p>The simplest method is to add an entry to your <code>/etc/hosts</code> file:</p> <pre><code>127.0.0.1 localhost podinfo1.ingress.kubodoc.local\n</code></pre> <p>Ensure the FQDN matches exactly what was defined in the <code>Release</code> parameters.</p> <p>You should now be able to access the <code>podinfo</code> web server:</p> <p>\ud83d\udc49 http://podinfo1.ingress.kubodoc.local</p>"},{"location":"user-guide/160-the-context/","title":"The Context","text":"<p>One of KuboCD's key features is its ability to generate Helm value files from a concise set of high-level input parameters using a templating mechanism.</p> <p>This mechanism combines a template with a data model.</p> <p>Our previous example used only the <code>.Parameters</code> element of the data model:</p> podinfo-p01.yaml <pre><code>apiVersion: v1alpha1\ntype: Package\nname: podinfo\n...\nmodules:\n  - name: main\n    ...\n    values: |\n      ingress:\n        enabled: true\n        className: {{ .Parameters.ingressClassName }}\n        hosts:\n          - host: {{ .Parameters.fqdn }}\n            paths:\n              - path: /\n                pathType: ImplementationSpecific\n</code></pre> <p>However, the full data model includes the following top-level elements:</p> <ul> <li><code>.Parameters</code>: The parameters provided in the <code>Release</code> custom resource.</li> <li><code>.Release</code>: The release object itself.</li> <li><code>.Context</code>: The deployment context.</li> </ul> <p>The Context is a flexible YAML object designed to hold shared configuration data relevant across multiple deployments.</p> <p>For example, the <code>podinfo</code> package includes an <code>ingressClassName</code> parameter with a default value of <code>nginx</code>. If a cluster uses a different ingress controller, this value would need to be overridden for every <code>Release</code>. Ideally, widespread configuration like this should be defined once in a global cluster-level context.</p> <p>Similarly, if all application ingress URLs share a common root domain, that domain should also be centralized.</p> <p>Here is how to implement this logic.</p>"},{"location":"user-guide/160-the-context/#creating-a-context","title":"Creating a Context","text":"<p>A <code>Context</code> is a KuboCD Custom Resource:</p> cluster.yaml <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Context\nmetadata:\n  namespace: contexts\n  name: cluster\nspec:\n  description: Global context for the kubodoc cluster\n  protected: true\n  context:\n    ingress:\n      className: nginx\n      domain: ingress.kubodoc.local\n    storageClass: \n      data: standard\n      workspace: standard\n    certificateIssuer:\n      public: cluster-self\n      internal: cluster-self\n</code></pre> <p>Key Attributes:</p> <ul> <li><code>description</code>: A short description of the context.</li> <li><code>protected</code>: Prevents accidental deletion (requires the KuboCD webhook).</li> <li><code>context</code>: A tree of values injected into the data model during <code>values</code> templating.<ul> <li>Must be valid YAML.</li> <li>Has a flexible structure but should align with what <code>Package</code> templates expect.</li> </ul> </li> </ul> <p>In this example, the context includes:</p> <ul> <li><code>ingress.className</code>: The ingress controller type.</li> <li><code>ingress.domain</code>: The suffix for ingress URLs.</li> <li><code>storageClass</code>: Definitions for <code>data</code> and <code>workspace</code> storage profiles (set to <code>standard</code> for Kind).</li> <li><code>certificateIssuer</code>: Identifiers for public and internal certificate issuers. (We will configure a self-signed CA in the cert-manager section).</li> </ul> <p>Cluster-wide contexts should be placed in a dedicated namespace:</p> <pre><code>kubectl create ns contexts\n</code></pre> <pre><code>kubectl apply -f contexts/cluster.yaml\n</code></pre> <p>Note</p> <p>Since the context is often shared across many applications, its structure should be carefully designed and well-documented.</p>"},{"location":"user-guide/160-the-context/#modifying-the-package","title":"Modifying the Package","text":"<p>Our initial <code>podinfo</code> package did not utilize the context. Here is an updated version that does:</p> podinfo-p02.yaml <pre><code>apiVersion: v1alpha1\ntype: Package\nname: podinfo\ntag: 6.7.1-p02\nschema:\n  parameters:\n    $schema: http://json-schema.org/schema#\n    type: object\n    additionalProperties: false\n    properties:\n      host: { type: string }\n    required:\n      - host\n  context:\n    $schema: http://json-schema.org/schema#\n    additionalProperties: true\n    type: object\n    properties:\n      ingress:\n        type: object\n        additionalProperties: true\n        properties:\n          className: { type: string }\n          domain: { type: string }\n        required:\n          - domain\n          - className\n    required:\n      - ingress\nmodules:\n  - name: main\n    source:\n      helmRepository:\n        url: https://stefanprodan.github.io/podinfo\n        chart: podinfo\n        version: 6.7.1\n    values: |\n      ingress:\n        enabled: true\n        className: {{ .Context.ingress.className  }}\n        hosts:\n          - host: {{ .Parameters.host }}.{{ .Context.ingress.domain }}\n            paths:\n              - path: /\n                pathType: ImplementationSpecific\n</code></pre> <p>Key Changes:</p> <ul> <li><code>tag</code>: updated to <code>6.7.1-p02</code>.</li> <li><code>host</code> parameter: Replaces <code>fqdn</code>. Now represents only the hostname (excluding the domain).</li> <li><code>modules[X].values</code>: Updated to use <code>.Context</code> variables.</li> <li><code>schema.context</code>: Added to define and validate the expected context structure.</li> </ul> <p>Pack and push this new version:</p> <pre><code>kubocd pack packages/podinfo-p02.yaml\n</code></pre> <pre><code>====================================== Packaging package 'podinfo-p02.yaml'\n--- Handling module 'main':\n    Fetching chart podinfo:6.7.1...\n    Chart: podinfo:6.7.1\n--- Packaging\n    Generating index file\n    Wrap all in assembly.tgz\n--- push OCI image: quay.io/kubodoc/packages/podinfo:6.7.1-p02\n    Successfully pushed\n</code></pre>"},{"location":"user-guide/160-the-context/#deployment-with-context","title":"Deployment with Context","text":"<p>Here is the corresponding <code>Release</code> manifest:</p> podinfo2-ctx.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo2\n  namespace: default\nspec:\n  description: A first sample release of podinfo\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p02\n  parameters:\n    host: podinfo2\n  contexts:\n    - namespace: contexts\n      name: cluster\n</code></pre> <p>Key Features:</p> <ul> <li>Interval Removed: <code>spec.package.interval</code> is omitted and will default to global settings (30m).</li> <li>Parameter Update: <code>fqdn</code> is replaced by <code>host</code>.</li> <li><code>contexts</code> Section: Lists contexts to merge into the template data model.</li> </ul> <p>Warning</p> <p>Referencing a non-existent context will result in an error.</p> <p>Apply the deployment:</p> <pre><code>kubectl apply -f releases/podinfo2-ctx.yaml\n</code></pre> <p>Check that the new <code>Release</code> is <code>READY</code>:</p> <pre><code>kubectl get releases podinfo2\n</code></pre> <pre><code>NAME       REPOSITORY                         TAG         CONTEXTS           STATUS   READY   WAIT   PRT   AGE   DESCRIPTION\npodinfo2   quay.io/kubodoc/packages/podinfo   6.7.1-p02   contexts:cluster   READY    1/1            -     17m   A first sample release of podinfo\n</code></pre> <p>Verify that the ingress has been configured correctly:</p> <pre><code>kubectl get ingresses podinfo2-main\n</code></pre> <pre><code>NAME            CLASS   HOSTS                            ADDRESS      PORTS   AGE\npodinfo2-main   nginx   podinfo2.ingress.kubodoc.local   10.96.59.9   80      120m\n</code></pre> <p>Note</p> <p>Remember to update your <code>/etc/hosts</code> or DNS if you wish to access this ingress.</p>"},{"location":"user-guide/160-the-context/#context-aggregation","title":"Context Aggregation","text":"<p>An application's effective context is often the result of aggregating multiple context objects.</p> <p>For instance, you might create a project-level context to share variables across all applications in a specific project, which is then merged with the global cluster context.</p>"},{"location":"user-guide/160-the-context/#example-1-merging-contexts","title":"Example 1: merging Contexts","text":"<p>Create a project namespace:</p> <pre><code>kubectl create namespace project01\n</code></pre> <p>Create the project context:</p> project01.yaml <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Context\nmetadata:\n  name: project01\nspec:\n  description: Context for project 1\n  context:\n    project:\n      id: p01\n      subdomain: prj01\n</code></pre> <p>Apply it to the namespace:</p> <pre><code>kubectl -n project01 apply -f contexts/project01.yaml\n</code></pre> <p>List all defined contexts:</p> <pre><code>kubectl get --all-namespaces contexts.kubocd.kubotal.io\n</code></pre> <pre><code>NAMESPACE   NAME        DESCRIPTION                          PARENTS   STATUS   AGE\ncontexts    cluster     Global context for the kubodoc cluster          READY    2d2h\nproject01   project01   Context for project 1                           READY    2m35s\n</code></pre> <p>We need to update the package to use the new <code>project.subdomain</code> variable:</p> podinfo-p03.yaml <pre><code>apiVersion: v1alpha1\ntype: Package\nname: podinfo\ntag: 6.7.1-p03\nschema:\n  parameters:\n    $schema: http://json-schema.org/schema#\n    type: object\n    additionalProperties: false\n    properties:\n      host: { type: string }\n    required:\n      - host\n  context:\n    $schema: http://json-schema.org/schema#\n    additionalProperties: true\n    type: object\n    properties:\n      ingress:\n        type: object\n        additionalProperties: true\n        properties:\n          className: { type: string }\n          domain: { type: string }\n        required:\n          - domain\n          - className\n      project:\n        type: object\n        additionalProperties: true\n        properties:\n          subdomain: { type: string }\n        required:\n          - subdomain\n    required:\n      - ingress\n      - project\nmodules:\n  - name: main\n    source:\n      helmRepository:\n        url: https://stefanprodan.github.io/podinfo\n        chart: podinfo\n        version: 6.7.1\n    values: |\n      ingress:\n        enabled: true\n        className: {{ .Context.ingress.className  }}\n        hosts:\n          - host: {{ .Parameters.host }}.{{ .Context.project.subdomain }}.{{ .Context.ingress.domain }}\n            paths:\n              - path: /\n                pathType: ImplementationSpecific\n</code></pre> <p>Pack the updated package:</p> <pre><code>kubocd pack packages/podinfo-p03.yaml\n</code></pre> <p>Create a new <code>Release</code>:</p> podinfo-prj01.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo\nspec:\n  description: A release of podinfo on project01\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p03\n  parameters:\n    host: podinfo\n  contexts:\n    - namespace: contexts\n      name: cluster\n    - name: project01\n  debug:\n    dumpContext: true\n    dumpParameters: true\n</code></pre> <p>Notes:</p> <ul> <li><code>metadata.namespace</code>: Not defined in the file; will be set via CLI.</li> <li><code>metadata.name</code>: Simply <code>podinfo</code>.</li> <li><code>spec.contexts</code>: Now includes two entries. The second one references the project context (defaults to the release namespace).</li> <li><code>debug</code>: Added to dump the resulting context and parameters into the <code>Release</code> status for inspection.</li> </ul> <p>Deploy the release:</p> <pre><code>kubectl -n project01 apply -f releases/podinfo-prj01.yaml\n</code></pre> <p>Verify that both contexts are active:</p> <pre><code>kubectl -n project01 get releases podinfo\n</code></pre> <pre><code>NAME      REPOSITORY                         TAG         CONTEXTS                               STATUS   READY   WAIT   PRT   AGE     DESCRIPTION\npodinfo   quay.io/kubodoc/packages/podinfo   6.7.1-p03   contexts:cluster,project01:project01   READY    1/1            -     8m31s   A release of podinfo on project01\n</code></pre> <p>Check the resulting ingress:</p> <pre><code>kubectl get --all-namespaces ingress\n</code></pre> <pre><code>NAMESPACE   NAME            CLASS   HOSTS                                 ADDRESS        PORTS   AGE\ndefault     podinfo1-main   nginx   podinfo1.ingress.kubodoc.local        10.96.207.51   80      4h46m\ndefault     podinfo2-main   nginx   podinfo2.ingress.kubodoc.local        10.96.207.51   80      4h6m\nproject01   podinfo-main    nginx   podinfo.prj01.ingress.kubodoc.local   10.96.207.51   80      4h\n</code></pre> <p>Inspect the <code>Release</code> status to see the merged context:</p> <pre><code>kubectl -n project01 get release podinfo -o yaml\n</code></pre> <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  ....\nspec:\n  ....\nstatus:\n  context:\n    ingress:\n      className: nginx\n      domain: ingress.kubodoc.local\n    project:\n      id: p01\n      subdomain: prj01\n    storageClass:\n      data: standard\n      workspace: standard\n  ....      \n  parameters:\n    host: podinfo2\n  ....\n</code></pre> <p>Warning</p> <p>In production, contexts can become large. Use <code>debug</code> mode sparingly.</p>"},{"location":"user-guide/160-the-context/#example-2-context-overrides","title":"Example 2: Context Overrides","text":"<p>In this example, we keep the objective (adding a subdomain) but use the <code>podinfo-p02</code> package (which does not use <code>project.subdomain</code>). Instead, we will override <code>ingress.domain</code>.</p> <p>Create a dedicated namespace:</p> <pre><code>kubectl create ns project02\n</code></pre> <p>Create a project context:</p> project02.yaml <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Context\nmetadata:\n  name: project02\nspec:\n  description: Context for project 2\n  context:\n    project:\n      id: p02\n    ingress:\n      domain: prj02.ingress.kubodoc.local\n</code></pre> <pre><code>kubectl -n project02 apply -f contexts/project02.yaml\n</code></pre> <p>Notice that <code>ingress.domain</code> exists in both the cluster and project contexts. When merging, later contexts in the list override earlier ones.</p> <p>Create and deploy the release:</p> podinfo-prj02.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo\nspec:\n  description: A release of podinfo on project02\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p02\n  parameters:\n    host: podinfo\n  contexts:\n    - namespace: contexts\n      name: cluster\n    - name: project02\n  debug:\n    dumpContext: true\n    dumpParameters: true\n</code></pre> <pre><code>kubectl -n project02 apply -f releases/podinfo-prj02.yaml\n</code></pre> <p>Check the <code>Release</code> context:</p> <pre><code>kubectl -n project02 get release podinfo -o yaml\n</code></pre> <pre><code>status:\n  context:\n    ingress:\n      className: nginx\n      domain: prj02.ingress.kubodoc.local\n    project:\n      id: p02\n    storageClass:\n      data: standard\n      workspace: standard\n</code></pre> <p>Verify the ingress host:</p> <pre><code>kubectl get --all-namespaces ingress\n</code></pre> <pre><code>NAMESPACE   NAME            CLASS   HOSTS                                 ADDRESS        PORTS   AGE\ndefault     podinfo1-main   nginx   podinfo1.ingress.kubodoc.local        10.96.218.98   80      2d20h\ndefault     podinfo2-main   nginx   podinfo2.ingress.kubodoc.local        10.96.218.98   80      110m\nproject01   podinfo-main    nginx   podinfo.prj01.ingress.kubodoc.local   10.96.218.98   80      26m\nproject02   podinfo-main    nginx   podinfo.prj02.ingress.kubodoc.local   10.96.218.98   80      2m52s\n</code></pre>"},{"location":"user-guide/160-the-context/#modifying-contexts","title":"Modifying Contexts","text":"<p>Any change to a context resource is automatically propagated to all associated <code>Release</code> objects. However, actual updates (Helm upgrades) only occur for deployments that are genuinely affected by the change.</p> <p>For example, modify the <code>project01</code> context:</p> <pre><code>kubectl -n project01 patch context.kubocd.kubotal.io project01 --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/context/project/subdomain\", \"value\": \"project01\" }]'\n</code></pre> <p>Observe the ingress update:</p> <pre><code>kubectl get --all-namespaces ingress\n</code></pre> <p>The host <code>podinfo.project01.ingress.kubodoc.local</code> should appear shortly.</p> <p>To restore the original value:</p> <pre><code>kubectl -n project01 patch context.kubocd.kubotal.io project01 --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/context/project/subdomain\", \"value\": \"prj01\" }]'\n</code></pre>"},{"location":"user-guide/170-context-and-config/","title":"Context and Configuration","text":""},{"location":"user-guide/170-context-and-config/#default-context","title":"Default Context","text":"<p>As seen in the previous chapter, it is often necessary to include a global cluster context in every <code>Release</code>. Rather than manually specifying this in every deployment manifest, it can be defined as a default context in the global configuration.</p>"},{"location":"user-guide/170-context-and-config/#config-resource","title":"Config Resource","text":"<p>Unlike many Kubernetes applications that use <code>ConfigMaps</code>, KuboCD uses a dedicated Config Custom Resource.</p> <pre><code>kubectl -n kubocd get Config.kubocd.kubotal.io\n</code></pre> <p>A single instance usually exists (created during the initial Helm deployment):</p> <pre><code>NAME     AGE\nconf01   5d21h\n</code></pre> <p>Inspect its content:</p> <pre><code>kubectl -n kubocd get Config.kubocd.kubotal.io conf01 -o yaml\n</code></pre> <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Config\nmetadata:\n  name: conf01\n  namespace: kubocd\n  ...\nspec:\n  clusterRoles: []\n  defaultContexts: []\n  defaultHelmInterval: 30m0s\n  defaultHelmTimeout: 3m0s\n  defaultNamespaceContexts: []\n  defaultOnFailureStrategy: updateOnFailure\n  defaultPackageInterval: 30m0s\n  imageRedirects: []\n  onFailureStrategies:\n  ...\n</code></pre> <p>Attributes like <code>defaultContexts</code> and <code>defaultPackageInterval</code> are managed here. These will be detailed further in the Reference section.</p> <p>Note</p> <p>Using a Custom Resource for configuration provides immediate validation (structural errors are rejected) and allows KuboCD to watch for and instantly apply changes.</p>"},{"location":"user-guide/170-context-and-config/#configuring-default-contexts","title":"Configuring Default Contexts","text":"<p>Create a new configuration manifest to set the default context:</p> conf02.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Config\nmetadata:\n  name: conf02\n  namespace: kubocd\nspec:\n  defaultContexts:\n    - namespace: contexts\n      name: cluster\n</code></pre> <p>Apply it:</p> <pre><code>kubectl apply -f configs/conf02.yaml \n</code></pre> <p>Note: Any warnings can be ignored during this step.</p> <p>Merging Configurations</p> <p>KuboCD allows breaking configuration across multiple resources. All <code>Config</code> resources in the controller's namespace (<code>kubocd</code>) are merged to form the global configuration.</p> <p>Resources are processed in alphabetic order, with later values overriding earlier ones.</p> <p>Tip</p> <p>Use <code>kubocd dump config</code> to view the final merged configuration.</p> <p>Now, we can create a <code>Release</code> without explicitly specifying the context:</p> podinfo3-ctx-def.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo3\n  namespace: default\nspec:\n  description: A first sample release of podinfo\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p02\n  parameters:\n    host: podinfo3\n</code></pre> <pre><code>kubectl apply -f releases/podinfo3-ctx-def.yaml \n</code></pre> <p>Verify that the context was automatically applied:</p> <pre><code>kubectl get release podinfo3\n</code></pre> <pre><code>NAME       REPOSITORY                         TAG         CONTEXTS           STATUS   READY   WAIT   PRT   AGE   DESCRIPTION\npodinfo3   quay.io/kubodoc/packages/podinfo   6.7.1-p02   contexts:cluster   READY    1/1            -     31m   A first sample release of podinfo\n</code></pre> <p>And confirm the ingress domain generation:</p> <pre><code>kubectl get ingress podinfo3-main\n</code></pre>"},{"location":"user-guide/170-context-and-config/#namespaced-default-contexts","title":"Namespaced Default Contexts","text":"<p>KuboCD also supports defining a default context per namespace.</p> <p>Update the global configuration to enable this feature:</p> conf03.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Config\nmetadata:\n  name: conf03\n  namespace: kubocd\nspec:\n  defaultNamespaceContexts: \n    - project\n</code></pre> <pre><code>kubectl apply -f configs/conf03.yaml \n</code></pre> <p>With this setting, every <code>Release</code> will check its own namespace for a context named <code>project</code> and use it if found.</p> <p>Create a new namespace <code>project03</code>:</p> <pre><code>kubectl create ns project03\n</code></pre> <p>Create a project-specific context named <code>project</code> in that namespace:</p> project03.yaml <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Context\nmetadata:\n  name: project\nspec:\n  description: Context For projet 3\n  context:\n    project:\n      id: p03\n    ingress:\n      domain: prj03.ingress.kubodoc.local\n</code></pre> <pre><code>kubectl -n project03 apply -f contexts/project03.yaml \n</code></pre> <p>Deploy a <code>Release</code> without specifying contexts:</p> podinfo-prj03.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo\nspec:\n  description: A release of podinfo on project03\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p02\n    interval: 30m\n  parameters:\n    host: podinfo\n  debug:\n    dumpContext: true\n    dumpParameters: true\n</code></pre> <pre><code>kubectl -n project03 apply -f releases/podinfo-prj03.yaml\n</code></pre> <p>Verify that both default contexts (global <code>cluster</code> and local <code>project</code>) are used:</p> <pre><code>kubectl -n project03 get release podinfo\n</code></pre> <pre><code>NAME      REPOSITORY                         TAG         CONTEXTS                             STATUS   READY   WAIT   PRT   AGE   DESCRIPTION\npodinfo   quay.io/kubodoc/packages/podinfo   6.7.1-p02   contexts:cluster,project03:project   READY    1/1            -     10m   A release of podinfo on project03\n</code></pre>"},{"location":"user-guide/170-context-and-config/#context-ordering","title":"Context Ordering","text":"<p>The order in which contexts are merged is critical, as later values override earlier ones. The precedence order is:</p> <ol> <li>Global Default Contexts (in list order).</li> <li>Namespace Default Contexts (if they exist).</li> <li>Release-Specific Contexts (in list order).</li> </ol> <p>Warning</p> <p>Referencing a non-existent context in <code>spec.contexts</code> results in an error. Missing namespace default contexts are ignored silently.</p> <p>Tip</p> <p>Use <code>kubocd dump context</code> to inspect the resolved context for a specific namespace.</p>"},{"location":"user-guide/170-context-and-config/#disabling-default-contexts","title":"Disabling Default Contexts","text":"<p>If you need to disable default context merging for a specific <code>Release</code>, use the <code>skipDefaultContext: true</code> flag in the <code>Release</code> specification.</p>"},{"location":"user-guide/170-context-and-config/#configuration-via-helm-chart","title":"Configuration via Helm Chart","text":"<p>In a real setup, you can define these configurations directly during the KuboCD installation via Helm values.</p> <p>Example <code>values1-ctrl.yaml</code>:</p> values1-ctrl.yaml <pre><code>extraNamespaces:\n  - name: contexts\nconfig:\n  enabled: true\n  content:\n    defaultContexts:\n      - name: cluster\n        namespace: contexts\n    defaultNamespaceContexts:\n      - project\ncontexts:\n  - name: cluster\n    namespace: contexts\n    protected: true\n    description: Context specific to the cluster 'kubodoc'\n    context:\n      ingress:\n        className: nginx\n        domain: ingress.kubodoc.local\n      storageClass:\n        data: standard\n        workspace: standard\n      certificateIssuer:\n        public: cluster-self\n        internal: cluster-self\n</code></pre> <p>Upgrade the deployment:</p> <pre><code>helm -n kubocd upgrade kubocd-ctrl oci://quay.io/kubocd/charts/kubocd-ctrl:v0.3.0 --values helm-values/values1-ctrl.yaml\n</code></pre> <p>Adoption Error</p> <p>If you manually created the <code>contexts</code> namespace and <code>cluster</code> context earlier, Helm will fail to adopt them. Delete them first:</p> <pre><code>kubectl -n contexts delete context.kubocd.kubotal.io cluster\nkubectl delete ns contexts\n</code></pre> <p>Then re-run the upgrade.</p> <p>Once managed by Helm, you can remove the manual config resources:</p> <pre><code>kubectl -n kubocd delete config.kubocd.kubotal.io conf02\nkubectl -n kubocd delete config.kubocd.kubotal.io conf03\n</code></pre>"},{"location":"user-guide/180-kubocd-cli/","title":"The KuboCD CLI","text":""},{"location":"user-guide/180-kubocd-cli/#kubocd-package","title":"kubocd package","text":"<p>Creates a KuboCD package from a manifest and stores it in an OCI image repository.</p> <p>See A First Deployment / Package Build for usage examples.</p> <pre><code>Assemble a KuboCD Package from a manifest to an OCI image\n\nUsage:\n  kubocd package &lt;Package manifest&gt; [flags]\n\nAliases:\n  package, pack, build\n\nExamples:\n    Build and push a package:\n    $ kubocd package podinfo-p01.yaml --ociRepoPrefix quay.io/kubodoc/packages\n\n    or\n    $ export OCI_REPO_PREFIX=quay.io/kubodoc/packages\n    $ kubocd package podinfo-p01.yaml\n\nFlags:\n  -h, --help                   help for package\n  -r, --ociRepoPrefix string   OCI repository prefix (e.g., 'quay.io/org/packages'). Also definable via OCI_REPO_PREFIX env var.\n  -p, --plainHTTP              Use plain HTTP instead of HTTPS when pushing image\n  -w, --workDir string         Working directory. Defaults to $HOME/.kubocd\n</code></pre>"},{"location":"user-guide/180-kubocd-cli/#kubocd-dump-package","title":"kubocd dump package","text":"<p>Displays the contents of a KuboCD package.</p> <pre><code>Dump KuboCD Package\n\nUsage:\n  kubocd dump package &lt;package.yaml|oci://repo:version&gt; [flags]\n\nAliases:\n  package, pck, Package, Pck, pack, Pack\n\nExamples:\n    Dump package content from an OCI image repository\n    $ kubocd dump package oci://quay.io/kubodoc/packages/podinfo:6.7.1-p01\n\n    Dump package content from a manifest\n    $ kubocd dump package podinfo-p01.yaml\n\n    Dump package content from a manifest and fetch Helm charts\n    $ kubocd dump package podinfo-p01.yaml --charts\n\nFlags:\n  -a, --anonymous       Connect anonymously to the registry.\n  -c, --charts          Unpack charts in output directory.\n  -h, --help            help for package.\n  -i, --insecure        Use insecure connection (HTTP).\n  -o, --output string   Output dump directory (default \"./.dump\").\n\nGlobal Flags:\n  -w, --workDir string   Working directory. Defaults to $HOME/.kubocd.\n</code></pre> <p>Example:</p> <pre><code>kubocd dump package oci://quay.io/kubodoc/packages/podinfo:6.7.1-p01\n</code></pre> <p>Output:</p> <pre><code>Create .dump/podinfo/status.yaml\nCreate .dump/podinfo/original.yaml\nCreate .dump/podinfo/groomed.yaml\nCreate .dump/podinfo/default-parameters.yaml\nCreate .dump/podinfo/default-context.yaml\n</code></pre> <p>The <code>.dump</code> directory contains:</p> <ul> <li><code>original.yaml</code>: The original manifest.</li> <li><code>groomed.yaml</code>: The normalized manifest with defaults applied.</li> <li><code>default-parameters.yaml</code>: Default values extracted from the schema.</li> <li><code>default-context.yaml</code>: Default context values extracted from the schema.</li> </ul> <p>To extract embedded Helm charts:</p> <pre><code>kubocd dump package packages/podinfo-p01.yaml --charts\n</code></pre>"},{"location":"user-guide/180-kubocd-cli/#kubocd-dump-helmrepository","title":"kubocd dump helmRepository","text":"<p>Explore the contents of a remote Helm repository.</p> <pre><code>Usage:\n  kubocd dump helmRepository repoUrl [chartName [version]] [flags]\n\nAliases:\n  helmRepository, hr, HelmRepository, helmRepo\n\nExamples:\n    List charts from helm repositories\n    $ kubocd dump helmRepository https://stefanprodan.github.io/podinfo\n\n    List all versions for a chart\n    $ kubocd dump helmRepository https://stefanprodan.github.io/podinfo podinfo\n\n    View chart information\n    $ kubocd dump helmRepository https://stefanprodan.github.io/podinfo podinfo 6.8.0\n\n    Download the chart locally\n    $ kubocd dump helmRepository https://stefanprodan.github.io/podinfo podinfo 6.8.0 --chart\n</code></pre> <p>Examples:</p> <p>List charts:</p> <pre><code>kubocd dump helmRepository https://stefanprodan.github.io/podinfo\n</code></pre> <p>Download a chart:</p> <pre><code>kubocd dump helmRepository https://stefanprodan.github.io/podinfo podinfo 6.8.0 --chart\n</code></pre> <p>Tip</p> <p>If a Helm chart is OCI-based, use <code>helm pull</code>.</p>"},{"location":"user-guide/180-kubocd-cli/#kubocd-dump-context","title":"kubocd dump context","text":"<p>Displays the application context as resolved by KuboCD. Requires cluster access.</p> <pre><code>Usage:\n  kubocd dump context [flags]\n\nAliases:\n  context, ctx\n\nExamples:\n    Display the context for the default namespace:\n    $ kubocd dump context\n\n    Display the context for project03:\n    $ kubocd dump context --namespace project03\n\n    Aggregate specific contexts:\n    $ kubocd dump context --skipDefaultContext --context contexts:cluster --context project01:project01\n</code></pre> <p>Example:</p> <pre><code>kubocd dump context --namespace project03\n</code></pre> <p>Output:</p> <pre><code>---\ningress:\n  className: nginx\n  domain: prj03.ingress.kubodoc.local\nproject:\n  id: p03\nstorageClass:\n  data: standard\n  workspace: standard\n</code></pre>"},{"location":"user-guide/180-kubocd-cli/#kubocd-dump-config","title":"kubocd dump config","text":"<p>Displays the global KuboCD configuration. Requires cluster access.</p> <pre><code>Usage:\n  kubocd dump config [flags]\n\nAliases:\n  config, Config\n</code></pre> <p>Example:</p> <pre><code>kubocd dump config\n</code></pre> <p>Output:</p> <pre><code>---\nclusterRoles: []\ndefaultContexts:\n- name: cluster\n  namespace: contexts\ndefaultHelmInterval: 30m0s\n...\n</code></pre>"},{"location":"user-guide/180-kubocd-cli/#kubocd-render","title":"kubocd render","text":"<p>Previews all resources that will be deployed by a <code>Release</code>. Ideally used to validate a <code>Package</code> or <code>Release</code> before deployment.</p> <pre><code>Render a KuboCD release\n\nUsage:\n  kubocd render &lt;Release manifest&gt; [&lt;package manifest&gt;] [flags]\n\nExamples:\n    Preview a Release.\n    $ render releases/podinfo2-ctx.yaml\n\n    Preview a Release using an alternate package manifest.\n    $ kubocd render releases/podinfo1.yaml packages/podinfo-p01.yaml\n</code></pre> <p>Example:</p> <pre><code>kubocd render releases/podinfo2-ctx.yaml\n</code></pre> <p>Output files in the <code>.render</code> directory include:</p> File Description <code>release.yaml</code> Final <code>Release</code> manifest. <code>package.yaml</code> Processed package manifest. <code>context.yaml</code> The full resolved context. <code>parameters.yaml</code> The final parameters. <code>model.yaml</code> The complete data model used for templating. <code>modules/main/values.yaml</code> Templated Helm values. <code>modules/main/manifests.yaml</code> <code>helm template</code> output. <p>Tip</p> <p>It is good practice to run <code>kubocd render</code> against your manifests before applying them to the cluster.</p>"},{"location":"user-guide/190-alternate-schema-format/","title":"Alternate KuboCD Schema Format","text":"<p>In previous examples, we defined <code>schema.parameters</code> and <code>schema.context</code> using standard OpenAPI/JSON schema. While fully supported, this syntax can be verbose.</p> <p>KuboCD provides a concise schema syntax specifically designed to simplify this definition.</p> <p>Comparing the <code>schema</code> section of the <code>podinfo</code> Package:</p> <p>Standard OpenAPI:</p> <pre><code>schema:\n  parameters:\n    $schema: http://json-schema.org/schema#\n    type: object\n    additionalProperties: false\n    properties:\n      host: { type: string }\n    required:\n      - host\n  context:\n    $schema: http://json-schema.org/schema#\n    additionalProperties: true\n    type: object\n    properties:\n      ingress:\n        type: object\n        additionalProperties: true\n        properties:\n          className: { type: string }\n          domain: { type: string }\n        required:\n          - domain\n          - className\n    required:\n      - ingress\n</code></pre> <p>KuboCD Simplified Format:</p> <pre><code>schema:\n  parameters:\n    properties:\n      host: { type: string, required: true }\n  context:\n    properties:\n      ingress:\n        required: true\n        properties:\n          className: { type: string, required: true }\n          domain: { type: string, required: true }\n</code></pre> <p>The simplified format is significantly more compact.</p> <p>Info</p> <p>This format is NOT standard OpenAPI.</p> <p>KuboCD distinguishes between the two formats by checking for the presence of the <code>$schema:</code> key.</p> <p>Key Differences:</p> <ul> <li>No <code>$schema:</code> key.</li> <li>Required fields are defined as boolean attributes on the node (<code>required: true</code>) rather than in a separate list.</li> <li><code>additionalProperties: false</code> is automatically implied for all objects in <code>schema.parameters</code>.</li> <li><code>additionalProperties: true</code> is automatically implied for all objects in <code>schema.context</code>.</li> <li><code>type: object</code> is inferred if <code>properties</code> is present.</li> <li><code>type: array</code> is inferred if <code>items</code> is present.</li> <li>Other attributes (<code>default</code>, <code>enum</code>, <code>pattern</code>, etc.) remain unchanged.</li> </ul> <p>When building a Package with this simplified format, KuboCD automatically converts it to standard OpenAPI/JSON schema. This normalized version is stored in the artifact and is viewable via <code>kubocd dump package</code> or <code>kubocd render</code>.</p> <p>Warning</p> <p>If you choose to use the standard form, remember to set <code>additionalProperties: false</code> on <code>schema.parameters</code> objects. Without it, typos in variable names will be ignored, leading to potential deployment issues.</p> <p>For the remainder of this manual, we will use the simplified KuboCD schema format.</p>"},{"location":"user-guide/200-redis/","title":"Advanced Features: Redis Sample","text":"<p>This chapter demonstrates advanced KuboCD features using a Redis deployment example.</p> redis-p01.yaml <pre><code>apiVersion: v1alpha1\nname: redis\ntag: 20.6.1-p01\ndescription: Redis and a front UI\nschema:\n  parameters:\n    properties:\n      redis:\n        properties:\n          password: { type: string, default: redis123 }\n          replicaCount: { type: integer, default: 1, description: \"The number of replicas\"}\n      ui:\n        required: true\n        properties:\n          enabled: { type: boolean, default: true }\n          host: { type: string, required: true }\n  context:\n    properties:\n      ingress:\n        required: true\n        properties:\n          className: { type: string, default: \"nginx\"}\n          domain: { type: string, required: true }\nmodules:\n  - name: noname\n    source:\n      oci:\n        repository: registry-1.docker.io/bitnamicharts/redis\n        tag: 20.6.1\n    values: |\n      image:\n        tag: latest\n      global:\n        redis:\n          password: {{ .Parameters.redis.password }}\n        security:\n          allowInsecureImages: true\n      master:\n        persistence:\n          enabled: false\n      replica:\n        persistence:\n          enabled: false\n        replicaCount: {{ .Parameters.redis.replicaCount }}\n  - name: ui\n    enabled: \"{{ .Parameters.ui.enabled }}\"\n    source:\n      git:\n        url: https://github.com/joeferner/redis-commander.git\n        path: ./k8s/helm-chart/redis-commander\n        branch: master\n    values: |\n      fullnameOverride: {{ .Release.metadata.name }}-ui\n      redis:\n        # host is &lt;fullnameOverride&gt;-&lt;moduleName&gt;-master\n        host: {{ printf \"%s-master\" .Release.metadata.name }}\n        password: {{ .Parameters.redis.password }}\n      ingress:\n        enabled: true\n        className: {{ .Context.ingress.className }}\n        hosts:\n          - host: {{ .Parameters.ui.host }}.{{.Context.ingress.domain}}\n            paths:\n              - \"/\"\n    dependsOn:\n      - noname\nroles: |\n  - redis\n  {{ if .Parameters.ui.enabled }}\n  - redis-ui\n  {{ end }}\ndependencies: |\n  {{ if .Parameters.ui.enabled }}\n  - ingress\n  {{ end }}\n</code></pre>"},{"location":"user-guide/200-redis/#multiple-modules","title":"Multiple Modules","text":"<p>This package integrates two modules:</p> <ol> <li>Redis Server: The core database.</li> <li>Redis Commander: A web-based management UI.</li> </ol> <p>Both modules share a single data model, allowing easy variable sharing. Consequently, <code>schema.parameters</code> and <code>schema.context</code> are global to the package.</p> <p>When deployed, Flux creates one <code>OCIRepository</code>, one <code>HelmRepository</code>, and two <code>HelmReleases</code>.</p> <p>Note that the main module is named <code>noname</code> to simplify resource naming.</p>"},{"location":"user-guide/200-redis/#mixed-source-types","title":"Mixed Source Types","text":"<ul> <li>Redis: Published as an OCI image. The <code>source</code> section references the OCI registry.     &gt; Note: The Bitnami Redis Docker image version in the chart is outdated, so we override the tag to <code>latest</code>.</li> <li>Redis Commander: Only provides a chart via GitHub. The <code>source</code> section references the Git repository.</li> </ul>"},{"location":"user-guide/200-redis/#conditional-deployment","title":"Conditional Deployment","text":"<p>The <code>ui</code> module includes an <code>enabled</code> attribute. This allows its deployment to be toggleable via a <code>Release</code> parameter (<code>.Parameters.ui.enabled</code>).</p>"},{"location":"user-guide/200-redis/#dependency-management","title":"Dependency Management","text":"<p>While Kubernetes applications often rely on retry loops to handle dependencies, KuboCD offers a structured dependency system.</p>"},{"location":"user-guide/200-redis/#module-dependencies","title":"Module Dependencies","text":"<p>Dependencies between modules within the same package:</p> <pre><code>modules:\n  - name: noname\n    ...\n  - name: ui\n    ...\n    dependsOn:\n      - noname\n</code></pre> <p>The <code>ui</code> module waits for the <code>noname</code> module (Redis) to become ready. This translates to a <code>dependsOn</code> rule in the underlying Flux <code>HelmRelease</code>.</p>"},{"location":"user-guide/200-redis/#release-dependencies-and-roles","title":"Release Dependencies and Roles","text":"<p>For dependencies between different Releases, KuboCD uses Roles.</p> <ul> <li>A <code>Release</code> can fulfill one or more roles.</li> <li>A <code>Release</code> can depend on one or more roles.</li> </ul> <p>This abstraction provides flexibility. For example, an application needing an ingress controller depends on the <code>ingress</code> role, regardless of the implementation (NGINX, Traefik, etc.).</p> <p>Roles and dependencies can be defined at:</p> <ul> <li>Package Level: Static definitions (like in the example above).</li> <li>Release Level: Dynamic definitions via <code>spec.roles</code> and <code>spec.dependencies</code>.</li> </ul> <p>During rendering, definitions from both levels are merged.</p>"},{"location":"user-guide/200-redis/#cluster-roles","title":"Cluster Roles","text":"<p>If a role is fulfilled by an external system (e.g., a pre-installed Ingress Controller on a cloud provider), it is defined as a ClusterRole.</p> <p>ClusterRoles are configured in the global <code>Config</code> resource to inform KuboCD that a dependency is externally satisfied.</p>"},{"location":"user-guide/200-redis/#deployment","title":"Deployment","text":""},{"location":"user-guide/200-redis/#packaging","title":"Packaging","text":"<p>Build the package:</p> <pre><code>kubocd pack packages/redis-p01.yaml \n</code></pre>"},{"location":"user-guide/200-redis/#full-deployment","title":"Full Deployment","text":"<p>Deploy both Redis and the UI:</p> redis1-basic.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: redis1\n  namespace: default\nspec:\n  package:\n    repository: quay.io/kubodoc/packages/redis\n    tag: 20.6.1-p01\n  parameters:\n    ui:\n      host: redis1\n</code></pre> <pre><code>kubectl apply -f releases/redis1-basic.yaml \n</code></pre> <p>Check status (Redis deployment may take time):</p> <pre><code>kubectl get release redis1\n</code></pre> <pre><code>NAME     REPOSITORY                       TAG          CONTEXTS           STATUS   READY   WAIT   PRT   AGE     DESCRIPTION\nredis1   quay.io/kubodoc/packages/redis   20.6.1-p01   contexts:cluster   READY    2/2            -     3m19s   Redis and a front UI\n</code></pre> <p>Note <code>READY 2/2</code>, indicating two active modules.</p> <p>Access the UI at: http://redis1.ingress.kubodoc.local (Requires DNS/hosts configuration).</p>"},{"location":"user-guide/200-redis/#redis-only-deployment","title":"Redis-Only Deployment","text":"<p>Deploy only the Redis server:</p> redis2-basic.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: redis2\n  namespace: default\nspec:\n  package:\n    repository: quay.io/kubodoc/packages/redis\n    tag: 20.6.1-p01\n  parameters:\n    ui:\n      enabled: false\n      host: dummy\n</code></pre> <p>Note: <code>host: dummy</code> is required to satisfy the schema validation, even though the UI is disabled.</p> <pre><code>kubectl apply -f releases/redis2-basic.yaml \n</code></pre> <p>Verify that only the Redis pod is created for <code>redis2</code>.</p> <p>Tip</p> <p>To avoid the <code>host: dummy</code> workaround, you can refine the schema using the normalized syntax to make parameters conditional. See sample implementation.</p>"},{"location":"user-guide/210-cert-manager/","title":"Cert-Manager Setup","text":"<p>Warning</p> <p>Existing Clusters: If cert-manager is already installed, do not install another one. However, read this section to understand the concepts.</p> <p>If you are using the local <code>kind</code> cluster, continue with this installation.</p>"},{"location":"user-guide/210-cert-manager/#components","title":"Components","text":"<p>We will deploy:</p> <ul> <li>cert-manager: Automates issuance and renewal of TLS certificates.</li> <li>trust-manager: Distributes trusted CA certificates across the cluster.</li> </ul> <p>After deployment, we will configure:</p> <ol> <li>Self-Signed CA: A private Certificate Authority within the cluster.</li> <li>Trust Bundle: A collection of trusted CAs distributed by trust-manager to ensure services trust the self-signed CA.</li> </ol>"},{"location":"user-guide/210-cert-manager/#the-kubocd-package","title":"The KuboCD Package","text":"<p>We group all components into a single package with three modules:</p> <ul> <li><code>noname</code>: Deploys <code>cert-manager</code>. (Using <code>noname</code> prevents suffixing resource names).</li> <li><code>trust</code>: Deploys <code>trust-manager</code>.</li> <li><code>issuer</code>: An ad hoc Helm chart that configures the self-signed CA and Trust Bundle.</li> </ul> cert-manager-p01.yaml <pre><code>apiVersion: v1alpha1\nname: cert-manager\ntag: 1.17.1-p01\nprotected: true\nschema:\n  parameters:\n    properties:\n      trust:\n        properties:\n          enabled: { type: boolean, default: false }\n          bundle:\n            properties:\n              name: { type: string, default: certs-bundle }\n              target:\n                properties:\n                  configMap:\n                    properties:\n                      enabled: { type: boolean, default: false }\n                      key: { type: string, default: \"root-certs.pem\" }\n                  secret:\n                    properties:\n                      enabled: { type: boolean, default: false }\n                      key: { type: string, default: \"ca.crt\" }\n      issuers:\n        properties:\n          enabled: { type: boolean, default: true }\n          caClusterIssuers:\n            items:\n              properties:\n                name: { type: string, required: true }\n                ca_crt: { type: string, required: true }\n                ca_key: { type: string, required: true }\n          selfSignedClusterIssuers:\n            items:\n              type: object\n              properties:\n                name: { type: string, required: true}\nmodules:\n  - name: noname\n    source:\n      helmRepository:\n        url: https://charts.jetstack.io\n        chart: cert-manager\n        version: v1.17.1\n    values: |\n      installCRDs: true\n      enableCertificateOwnerRef: true\n  - name: trust\n    enabled: \"{{ .Parameters.trust.enabled }}\"\n    source:\n      helmRepository:\n        url: https://charts.jetstack.io\n        chart: trust-manager\n        version: v0.16.0\n    values: |\n      app:\n        trust:\n          namespace: {{ .Release.spec.targetNamespace }}\n      secretTargets:\n        enabled: {{ and .Parameters.trust.enabled .Parameters.trust.bundle.target.secret.enabled }}\n        authorizedSecrets:\n          - {{ .Parameters.trust.bundle.name }}\n    dependsOn:\n      - noname\n  - name: issuers\n    enabled: \"{{ .Parameters.issuers.enabled }}\"\n    source:\n      local:\n        path: ../charts/cert-issuers/0.1.0\n    values: |\n      {{ toYaml .Parameters.issuers }}\n      bundle:\n        name: {{ .Parameters.trust.bundle.name }}\n        target:\n          configMap:\n            enabled: {{ .Parameters.trust.bundle.target.configMap.enabled }}\n            key: {{ .Parameters.trust.bundle.target.configMap.key }}\n          secret:\n            enabled: {{ .Parameters.trust.bundle.target.secret.enabled }}\n            key: {{ .Parameters.trust.bundle.target.secret.key }}\n    dependsOn: |\n      - noname\n      {{ if and .Parameters.trust.enabled }}\n      - trust\n      {{ end }}\nroles:\n  - certManager\n</code></pre> <p>Scope</p> <p>Detailed configuration of cert-manager itself is outside the scope of this manual. Refer to the official documentation.</p>"},{"location":"user-guide/210-cert-manager/#local-helm-chart-source","title":"Local Helm Chart Source","text":"<p>This example introduces a local source for Helm charts. The <code>cert-issuers</code> chart is stored alongside the manifest and referenced via <code>modules[3].source.local.path</code>. During packaging, this local chart is embedded into the OCI image.</p>"},{"location":"user-guide/210-cert-manager/#deployment","title":"Deployment","text":"<p>Build the package:</p> <pre><code>kubocd pack packages/cert-manager-p01.yaml\n</code></pre> <p>Create the Release:</p> cert-manager.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: cert-manager\n  namespace: kubocd\nspec:\n  description: The certificate manager\n  package:\n    repository: quay.io/kubodoc/packages/cert-manager\n    tag: 1.17.1-p01\n  parameters:\n    issuers:\n      selfSignedClusterIssuers:\n        - name: cluster-self\n    trust:\n      enabled: true\n      bundle:\n        target:\n          configMap:\n            enabled: true\n          secret:\n            enabled: true\n  targetNamespace: cert-manager\n  createNamespace: true \n</code></pre> <p>The <code>Release</code> resides in the <code>kubocd</code> namespace, but it installs the application into <code>cert-manager</code> (via <code>targetNamespace</code>).</p> <p>Apply the manifest:</p> <pre><code>kubectl apply -f releases/cert-manager.yaml\n</code></pre> <p>Check the status (wait for <code>READY 3/3</code>):</p> <pre><code>kubectl -n kubocd get releases cert-manager\n</code></pre> <p>Verify pods:</p> <pre><code>kubectl -n cert-manager get pods\n</code></pre> <p>The <code>trust-manager</code> controller distributes the trust bundle (as both Secret and ConfigMap) to all namespaces. Verify distribution using:</p> <pre><code>kubectl get --all-namespaces secrets | grep certs-bundle\n</code></pre>"},{"location":"user-guide/210-cert-manager/#secure-podinfo","title":"Secure Podinfo","text":"<p>Now we use this infrastructure to secure the <code>podinfo</code> application.</p> <p>Update the package to support TLS:</p> podinfo-p04.yaml <pre><code>apiVersion: v1alpha1\ntype: Package\nname: podinfo\ntag: 6.7.1-p04\nschema:\n  parameters:\n    properties:\n      host: { type: string, required: true }\n      tls: { type: boolean, default: false }\n  context:\n    properties:\n      ingress:\n        required: true\n        properties:\n          className: { type: string, required: true }\n          domain: { type: string, required: true }\nmodules:\n  - name: noname\n    source:\n      helmRepository:\n        url: https://stefanprodan.github.io/podinfo\n        chart: podinfo\n        version: 6.7.1\n    values: |\n      ingress:\n        enabled: true\n        className: {{ .Context.ingress.className  }}\n        {{- if .Parameters.tls }}\n        annotations:\n          cert-manager.io/cluster-issuer: {{ required \".Context.certificateIssuer.public must be defined if tls: true\" .Context.certificateIssuer.public }}\n        {{- end }}\n        hosts:\n          - host: {{ .Parameters.host }}.{{ .Context.ingress.domain }}\n            paths:\n              - path: /\n                pathType: ImplementationSpecific\n        {{- if .Parameters.tls }}\n        tls:\n          - secretName: {{ .Release.metadata.name }}-tls\n             hosts:\n               - {{  .Parameters.host }}.{{ .Context.ingress.domain }}\n        {{- end }}\n</code></pre> <p>Pack the update:</p> <pre><code>kubocd pack packages/podinfo-p04.yaml\n</code></pre> <p>Deploy the secured release:</p> podinfo4-tls.yaml <pre><code>---\napiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo4\n  namespace: default\nspec:\n  description: A secured release of podinfo\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p04\n  parameters:\n    tls: true\n    host: podinfo4\n</code></pre> <pre><code>kubectl apply -f releases/podinfo4-tls.yaml\n</code></pre> <p>Verify the ingress now serves on port 443:</p> <pre><code>kubectl get ingresses podinfo4\n</code></pre> <p>Access the secured URL:</p> <p>\ud83d\udc49 https://podinfo4.ingress.kubodoc.local</p> <p>Note: You will encounter browser security warnings because we are using a self-signed certificate.</p>"},{"location":"user-guide/220-deployment-failure/","title":"Handling Deployment Failures","text":"<p>This chapter explains how to handle failures during KuboCD <code>Release</code> deployments.</p> <p>As described in Under the hood, KuboCD generates a FluxCD <code>HelmRelease</code> resource for each module in a package. The Flux <code>helm-controller</code> then executes the deployment using its embedded Helm instance.</p> <p>The Flux <code>HelmRelease</code> resource provides several parameters to configure behavior when failures occur:</p> <ul> <li><code>HelmRelease.spec.timeout</code>: The wait time for individual Kubernetes operations (e.g., Hooks) during a Helm action.</li> <li><code>HelmRelease.spec.install</code>: Configuration for Helm install actions.</li> <li><code>HelmRelease.spec.upgrade</code>: Configuration for Helm upgrade actions.</li> </ul> <p>For full details, refer to the Flux documentation for install and upgrade.</p>"},{"location":"user-guide/220-deployment-failure/#failure-strategies","title":"Failure Strategies","text":"<p>A common requirement is to automatically retry or remediate failed deployments. For example, a configuration that attempts to uninstall and re-install a failed release up to 10 times:</p> <pre><code>spec:\n  install:\n    strategy:\n      name: RemediateOnFailure\n    remediation:\n      retries: 10\n  upgrade:\n    strategy:\n      name: RemediateOnFailure\n    remediation:\n      retries: 10\n</code></pre> <p>To avoid manually defining these verbose configurations for every release, KuboCD allows you to define named strategies in the global configuration (<code>Config</code>).</p>"},{"location":"user-guide/220-deployment-failure/#configuring-global-strategies","title":"Configuring Global Strategies","text":"<p>Sample <code>Config</code> resource:</p> <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Config\nmetadata:\n  name: global-config\nspec:\n  defaultHelmTimeout: 3m0s\n  defaultOnFailureStrategy: updateOnFailure\n  onFailureStrategies:\n    - name: stopOnFailure\n      strategy: {}\n\n    - name: reinstallOnFailure\n      strategy:\n        install:\n          strategy:\n            name: RemediateOnFailure\n          remediation:\n            retries: 10\n        upgrade:\n          strategy:\n            name: RemediateOnFailure\n          remediation:\n            retries: 10\n\n    - name: updateOnFailure\n      strategy:\n        install:\n          strategy:\n            name: RetryOnFailure\n            retryInterval: 1m0s\n        upgrade:\n          strategy:\n            name: RetryOnFailure\n            retryInterval: 1m0s\n</code></pre> <p>Defined Strategies:</p> <ul> <li><code>stopOnFailure</code>: Do nothing on failure (default Flux behavior).</li> <li><code>reinstallOnFailure</code>: Uninstall and re-install up to 10 times.</li> <li><code>updateOnFailure</code>: Retry the update every minute until success.</li> </ul> <p>Default Settings:</p> <ul> <li><code>defaultOnFailureStrategy</code>: Sets the strategy used by default for all deployments (<code>updateOnFailure</code> in this example).</li> <li><code>defaultHelmTimeout</code>: Sets the default <code>HelmRelease.spec.timeout</code> (3 minutes).</li> </ul>"},{"location":"user-guide/220-deployment-failure/#applying-strategies","title":"Applying Strategies","text":"<p>Strategies can be applied or overridden at multiple levels:</p> <ol> <li>Global Default: As defined in <code>defaultOnFailureStrategy</code>.</li> <li>Package Level: Override per module using <code>package.module[X].onFailureStrategy</code> and <code>timeout</code>.</li> <li>Release Level: Override per module using <code>moduleOverrides</code>.</li> </ol> <p>Example: Overriding at Release Level</p> <pre><code>apiVersion: kubocd.kubotal.io/v1alpha1\nkind: Release\nmetadata:\n  name: podinfo1\n  namespace: default\nspec:\n  package:\n    repository: quay.io/kubodoc/packages/podinfo\n    tag: 6.7.1-p01\n  moduleOverrides:\n    main:\n      onFailureStrategy: reinstallOnFailure\n      timeout: 2m\n</code></pre> <p>In this example, the <code>main</code> module will use the <code>reinstallOnFailure</code> strategy and a custom timeout of 2 minutes.</p>"}]}